#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class TetrahedralMesh "TetrahedralMesh" (
    doc = """Deprecated: Will be replaced by UsdGeom.TetMesh in a future release.
          Describes a tetrahedral mesh in 3D space."""
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    int[] indices (
        displayGroup = "Advanced"
        displayName = "Indices"
        doc = "Flat list of the index (into the 'points' attribute) of each vertex of each tetrahedron in the mesh."
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "PhysxSceneAPI" (
    doc = """PhysX scene extended parameters.
    Default PhysX material for the scene can be set by using material bind with purpose physics onto the PhysicsScene prim."""
)
{
    float physxScene:bounceThreshold = 0 (
        displayGroup = "Advanced"
        displayName = "Bounce Threshold"
        doc = """A contact with a relative velocity below this will not bounce.
            Range: [0, inf)
            Default: 0
            Units: distance / seconds"""
    )
    uniform token physxScene:broadphaseType = "GPU" (
        allowedTokens = ["GPU", "MBP", "SAP"]
        displayName = "Broadphase Type"
        doc = "Broad phase algorithm used in the simulation."
    )
    uniform token physxScene:collisionSystem = "PCM" (
        allowedTokens = ["PCM", "SAT"]
        displayName = "Collision System"
        doc = "Collision detection system."
    )
    bool physxScene:enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Enables a second broad phase check after integration that makes it possible to prevent objects from tunneling through each other."
    )
    bool physxScene:enableEnhancedDeterminism = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Enhanced Determinism"
        doc = "Provides improved determinism at the expense of performance."
    )
    bool physxScene:enableExternalForcesEveryIteration = 0 (
        displayGroup = "Advanced"
        displayName = "Enable External Forces Every Iteration"
        doc = "Enables greater TGS solver stability."
    )
    bool physxScene:enableGPUDynamics = 1 (
        displayName = "Enable GPU Dynamics"
        doc = "Enables the GPU dynamics pipeline. Required for GPU only features like deformables."
    )
    bool physxScene:enableResidualReporting = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Residual Reporting"
        doc = "Calculates solver residuals and reports them through optional Residual Report APIs at a slight expense of performance."
    )
    bool physxScene:enableSceneQuerySupport = 1 (
        displayGroup = "Advanced"
        displayName = "Enable Scene Query Support"
        doc = "Enables scene query support for collision shapes."
    )
    bool physxScene:enableStabilization = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Stabilization"
        doc = "Enables additional stabilization pass in solver."
    )
    float physxScene:frictionCorrelationDistance = 0.025 (
        displayGroup = "Advanced"
        displayName = "Friction Correlation Distance"
        doc = """Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.
            Range: [0, inf)
            Default: 0.025 * tolerancesLength
            Units: distance"""
    )
    float physxScene:frictionOffsetThreshold = 0.04 (
        displayGroup = "Advanced"
        displayName = "Friction Offset Threshold"
        doc = """A threshold of contact separation distance used to decide if a contact point will experience friction forces.
            Range: [0, inf)
            Default: 0.04 * tolerancesLength
            Units: distance"""
    )
    uniform token physxScene:frictionType = "patch" (
        allowedTokens = ["patch"]
        displayGroup = "Advanced"
        displayName = "Friction Type"
        doc = '''Deprecated since friction type "patch" is the only option now.
        
                Friction type used in simulation.'''
    )
    uint physxScene:gpuCollisionStackSize = 67108864 (
        displayGroup = "Gpu"
        displayName = "Gpu Collision Stack Size"
        doc = "Gpu collision stack size."
    )
    uint physxScene:gpuFoundLostAggregatePairsCapacity = 1024 (
        displayGroup = "Gpu"
        displayName = "Gpu Found Lost Aggregate Pairs Capacity"
        doc = "Gpu found lost aggregate pairs capacity."
    )
    uint physxScene:gpuFoundLostPairsCapacity = 262144 (
        displayGroup = "Gpu"
        displayName = "Gpu Found Lost Pairs Capacity"
        doc = "Gpu found lost pairs capacity."
    )
    uint physxScene:gpuHeapCapacity = 67108864 (
        displayGroup = "Gpu"
        displayName = "Gpu Heap Capacity"
        doc = "Gpu heap capacity."
    )
    uint physxScene:gpuMaxDeformableSurfaceContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Deformable Surface Contacts"
        doc = "Gpu max deformable surface contacts."
    )
    uint physxScene:gpuMaxNumPartitions = 8 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Num Partitions"
        doc = "Limitation for the partitions in the GPU dynamics pipeline. This variable must be a power of 2. A value greater than 32 is currently not supported."
    )
    uint physxScene:gpuMaxParticleContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Particle Contacts"
        doc = "Gpu max particle contacts."
    )
    uint physxScene:gpuMaxRigidContactCount = 524288 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Rigid Contact Count"
        doc = "Gpu max rigid contact count."
    )
    uint physxScene:gpuMaxRigidPatchCount = 81920 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Rigid Patch Count"
        doc = "Gpu max rigid patch count."
    )
    uint physxScene:gpuMaxSoftBodyContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Softbody Contacts"
        doc = "Gpu max soft body contacts."
    )
    uint64 physxScene:gpuTempBufferCapacity = 16777216 (
        displayGroup = "Gpu"
        displayName = "Gpu Temp Buffer Capacity"
        doc = "Gpu temp buffer capacity."
    )
    uint physxScene:gpuTotalAggregatePairsCapacity = 1024 (
        displayGroup = "Gpu"
        displayName = "Gpu Total Aggregate Pairs Capacity"
        doc = "Gpu total aggregate pairs capacity."
    )
    bool physxScene:invertCollisionGroupFilter = 0 (
        displayName = "Inverted Collision Group Filter"
        doc = '''Boolean attribute indicating whether inverted collision group filtering should be used.
        By default two collisions, that do have a collisionGroup set, collide with each other. Adding
        a collisionGroup into a collisionGroup filtering will mean that the collision between those groups
        will be disabled. This boolean attribute does invert the default behavior. Hence two collisions with
        defined collisionGroups will not collide with each other by default and one does enable the
        collisions between the groups through the "CollisionGroup" filtering.'''
    )
    float physxScene:maxBiasCoefficient = inf (
        displayGroup = "Advanced"
        displayName = "Maximum Bias Coefficient"
        doc = """The maximum bias coefficient used in the constraint solver.
            Range: [0, inf)
            Units: dimensionless"""
    )
    uniform uint physxScene:maxPositionIterationCount = 255 (
        displayName = "Maximum Position Iteration Count"
        doc = """Maximum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations.
            Range: [1, 255]"""
    )
    uniform uint physxScene:maxVelocityIterationCount = 255 (
        displayName = "Maximum Velocity Iteration Count"
        doc = """Maximum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations.
            Range: [0, 255]"""
    )
    uniform uint physxScene:minPositionIterationCount = 1 (
        displayName = "Minimum Position Iteration Count"
        doc = """Minimum position iteration count for all actors (rigid bodies, cloth, particles etc).
            Range: [1, 255]"""
    )
    uniform uint physxScene:minVelocityIterationCount = 0 (
        displayName = "Minimum Velocity Iteration Count"
        doc = """Minimum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
            Range: [0, 255]"""
    )
    bool physxScene:reportKinematicKinematicPairs = 0 (
        displayName = "Report Kinematic vs Kinematic Pairs"
        doc = """Boolean attribute indicating whether kinematic vs kinematic pairs
        generate contact reports."""
    )
    bool physxScene:reportKinematicStaticPairs = 0 (
        displayName = "Report Kinematic vs Static Pairs"
        doc = """Boolean attribute indicating whether kinematic vs static pairs
        generate contact reports."""
    )
    uniform token physxScene:solverType = "TGS" (
        allowedTokens = ["PGS", "TGS"]
        displayName = "Solver Type"
        doc = "Solver used for the simulation."
    )
    uint physxScene:timeStepsPerSecond = 60 (
        displayName = "Time Steps Per Second"
        doc = """Simulation scene step defined as number of steps per second.
        Note that application might cap the number of simulation steps to avoid
        running more simulations steps with a low frame rate."""
    )
    uniform token physxScene:updateType = "Synchronous" (
        allowedTokens = ["Synchronous", "Asynchronous", "Disabled"]
        displayGroup = "Advanced"
        displayName = "Update Type"
        doc = "Type of update for a PhysX scene."
    )
}

class "PhysxRigidBodyAPI" (
    doc = "PhysX rigid body extended parameters"
)
{
    float physxRigidBody:angularDamping = 0.05 (
        displayName = "Angular Damping"
        doc = """Angular damping coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxRigidBody:cfmScale = 0.025 (
        displayGroup = "Advanced"
        displayName = "Constraint-force-mixing Scale"
        doc = """The cfm scale term can help stabilize an articulation by weakening the constraint's response.
            Use small values close to the default and typically in the range [0, 0.1] for best results.
            Note that this parameter is currently used only if rigid body is part of an articulation.
            Range: [0, 1]
            Units: unitless"""
    )
    float physxRigidBody:contactSlopCoefficient = 0 (
        displayGroup = "Advanced"
        displayName = "Contact Slop Coefficient"
        doc = """Tolerance on the angular influence of a contact that can help improve the behavior of rolling approximate collision shapes.
            Specifically, the angular component of a normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance.
            The tolerance is scaled such that the behavior improvement persists through a range of angular velocities of a rolling shape.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxRigidBody:disableGravity = 0 (
        displayName = "Disable Gravity"
        doc = "Disable gravity for the actor."
    )
    bool physxRigidBody:enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Enables swept integration for the actor."
    )
    bool physxRigidBody:enableGyroscopicForces = 1 (
        displayGroup = "Advanced"
        displayName = "Enable Gyroscopic Forces"
        doc = "Enables computation of gyroscopic forces on the rigid body."
    )
    bool physxRigidBody:enableSpeculativeCCD = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Speculative CCD"
        doc = "Register a rigid body to dynamically adjust contact offset based on velocity. This can be used to achieve a CCD effect."
    )
    float physxRigidBody:linearDamping = 0 (
        displayName = "Linear Damping"
        doc = """Linear damping coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    int physxRigidBody:lockedPosAxis = 0 (
        displayName = "Locked Pos Axis"
        doc = "Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2)."
    )
    int physxRigidBody:lockedRotAxis = 0 (
        displayName = "Locked Rot Axis"
        doc = "Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2)."
    )
    float physxRigidBody:maxAngularVelocity = 5729.58 (
        displayName = "Max Angular Velocity"
        doc = """Maximum allowable angular velocity for rigid body.
            Range: [0, inf)
            Units: degrees / seconds"""
    )
    float physxRigidBody:maxContactImpulse = inf (
        displayGroup = "Advanced"
        displayName = "Max Contact Impulse"
        doc = """Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic
            bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited
            by the value for the dynamic body.
            Range: [0, inf)
            Units: force * seconds = mass * distance / seconds"""
    )
    float physxRigidBody:maxDepenetrationVelocity = 3 (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum depenetration velocity permitted to be introduced by the solver.
            Range: [0, inf)
            Default: 5.0 * tolerancesLength
            Units: distance / seconds"""
    )
    float physxRigidBody:maxLinearVelocity = inf (
        displayName = "Max Linear Velocity"
        doc = """Maximum allowable linear velocity for the rigid body.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    bool physxRigidBody:retainAccelerations = 0 (
        displayGroup = "Advanced"
        displayName = "Retain Accelerations"
        doc = "Carries over forces/accelerations between frames, rather than clearing them."
    )
    float physxRigidBody:sleepThreshold = 0.00005 (
        displayName = "Sleep Threshold"
        doc = """Mass-normalized kinetic energy threshold below which an actor may go to sleep.
            Range: [0, inf)
            Default: 0.00005 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
    bool physxRigidBody:solveContact = 1 (
        displayGroup = "Advanced"
        displayName = "Solve Contact"
        doc = "Process the contacts of this rigid body in the dynamics solver."
    )
    int physxRigidBody:solverPositionIterationCount = 16 (
        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = "Solver position iteration counts for the body. Allowed range [1, 255]."
    )
    int physxRigidBody:solverVelocityIterationCount = 1 (
        displayGroup = "Advanced"
        displayName = "Solver Velocity Iteration Count"
        doc = "Solver velocity iteration counts for the body. Allowed range [0, 255]."
    )
    float physxRigidBody:stabilizationThreshold = 0.00001 (
        displayGroup = "Advanced"
        displayName = "Stabilization Threshold"
        doc = """Mass-normalized kinetic energy threshold below which an actor may participate in stabilization.
            Range: [0, inf)
            Default: 0.00001 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxContactReportAPI" (
    doc = "Enables contact reporting for a rigid body or articulation."
)
{
    rel physxContactReport:reportPairs (
        displayName = "Report Pairs"
        doc = "Relationship to objects. If in contact with these objects, contact reports will be sent. If relationship not set or list empty all contacts are reported."
    )
    float physxContactReport:threshold = 1 (
        displayName = "Contact Report Threshold"
        doc = """Sets the force threshold for contact reports.
            Range: [0, inf]
            Units: force = mass * distance / seconds / seconds"""
    )
}

class "PhysxCollisionAPI" (
    doc = "PhysX collision extended parameters"
)
{
    float physxCollision:contactOffset = -inf (
        displayGroup = "Advanced"
        displayName = "Contact Offset"
        doc = """Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent.
            Range: [maximum(0, restOffset), inf)
            Units: distance"""
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        displayGroup = "Advanced"
        displayName = "Min Torsional Patch Radius"
        doc = """Defines the minimum radius of the contact patch used to apply torsional friction.
            Range: [0, inf)
            Units: distance"""
    )
    float physxCollision:restOffset = -inf (
        displayGroup = "Advanced"
        displayName = "Rest Offset"
        doc = """Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value.
            For rigid bodies, this value is zero.
            Range: [0, contactOffset]
            Units: distance"""
    )
    float physxCollision:torsionalPatchRadius = 0 (
        displayGroup = "Advanced"
        displayName = "Torsional Patch Radius"
        doc = """Defines the radius of the contact patch used to apply torsional friction.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxConvexHullCollisionAPI" (
    doc = "PhysX convex hull collision extended parameters"
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        displayName = "Hull Vertex Limit"
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        displayGroup = "Advanced"
        displayName = "Min Thickness"
        doc = """Convex hull minimum thickness.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxConvexDecompositionCollisionAPI" (
    doc = "PhysX convex decomposition extended parameters"
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        displayGroup = "Advanced"
        displayName = "Error Percentage"
        doc = "Convex decomposition errorPercentage parameter."
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        displayName = "Hull Vertex Limit"
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        displayName = "Max Convex Hulls"
        doc = "Maximum of convex hulls created during convex decomposition."
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        displayGroup = "Advanced"
        displayName = "Min Thickness"
        doc = """Convex hull min thickness.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        displayGroup = "Advanced"
        displayName = "Shrink Wrap"
        doc = "Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        displayGroup = "Advanced"
        displayName = "Voxel Resolution"
        doc = "Voxel resolution used for convex decomposition."
    )
}

class "PhysxSphereFillCollisionAPI" (
    doc = "PhysX sphere fill extended parameters"
)
{
    uniform token physxSphereFillCollision:fillMode = "flood" (
        allowedTokens = ["flood", "raycast", "surface"]
        displayGroup = "Advanced"
        displayName = "Fill Mode"
        doc = "Fill mode for the the algorithm."
    )
    int physxSphereFillCollision:maxSpheres = 128 (
        displayName = "Max Spheres"
        doc = "Maximum of spheres produced. Range (2, 4000)"
    )
    int physxSphereFillCollision:seedCount = 1000 (
        displayGroup = "Advanced"
        displayName = "Seed Count"
        doc = "Seed count used for the algorithm. Range (16, 4000)"
    )
    int physxSphereFillCollision:voxelResolution = 50000 (
        displayGroup = "Advanced"
        displayName = "Voxel Resolution"
        doc = "Voxel resolution used for the algorithm. Range (10 000, 1 000 000)"
    )
}

class "PhysxTriangleMeshSimplificationCollisionAPI" (
    doc = "PhysX triangle mesh simplification extended parameters"
)
{
    float physxTriangleMeshSimplificationCollision:metric = 0.55 (
        displayName = "Simplification Metric"
        doc = "Mesh simplification accuracy."
    )
    float physxTriangleMeshSimplificationCollision:weldTolerance = -inf (
        displayGroup = "Advanced"
        displayName = "Weld Tolerance"
        doc = """Mesh weld tolerance, controls the distance at which vertices are welded. 
            Default -inf will autocompute the welding tolerance based on the mesh size. Zero value will disable welding.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxTriangleMeshCollisionAPI" (
    doc = "PhysX triangle mesh extended parameters"
)
{
    float physxTriangleMeshCollision:weldTolerance = -inf (
        displayGroup = "Advanced"
        displayName = "Weld Tolerance"
        doc = """Mesh weld tolerance, controls the distance at which vertices are welded. 
            Default -inf will autocompute the welding tolerance based on the mesh size. Zero value will disable welding.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxSDFMeshCollisionAPI" (
    doc = "PhysX SDF mesh extended parameters"
)
{
    uniform token physxSDFMeshCollision:sdfBitsPerSubgridPixel = "BitsPerPixel16" (
        allowedTokens = ["BitsPerPixel8", "BitsPerPixel16", "BitsPerPixel32"]
        displayGroup = "Advanced"
        displayName = "SDF Bits per Subgrid Pixel"
        doc = """Values of 8, 16 and 32 bits per subgrid pixel are supported. Dense SDFs always use 32 bits per pixel. The
            less bits per pixel, the smaller the resulting SDF but also the less precise. The SDF's memory consumption 
            scales proportionally with the number of bits per subgrid pixel."""
    )
    uniform bool physxSDFMeshCollision:sdfEnableRemeshing = 0 (
        displayGroup = "Advanced"
        displayName = "Enable SDF Remeshing"
        doc = """Enables optional remeshing as a preprocessing step before the SDF is computed. Remeshing can help generate 
            valid SDF data even if the input mesh has bad properties like inconsistent winding or self-intersections. The SDF
            distances (and therefore the collisions) will be slightly less accurate when remeshing is enabled."""
    )
    uniform float physxSDFMeshCollision:sdfMargin = 0.01 (
        displayGroup = "Advanced"
        displayName = "SDF Margin"
        doc = """Margin to increase the size of the SDF relative to the bounding box diagonal length of the mesh. A sdf 
            margin value of 0.01 means the sdf boundary will be enlarged in any direction by 1% of the mesh's bounding box 
            diagonal length. Representing the margin relative to the bounding box diagonal length ensures that it is scale 
            independent. Margins allow for precise distance queries in a region slightly outside of the mesh's bounding box.
            Range: [0, inf)
            Units: dimensionless"""
    )
    uniform float physxSDFMeshCollision:sdfNarrowBandThickness = 0.01 (
        displayGroup = "Advanced"
        displayName = "SDF Narrow Band Thickness"
        doc = """Size of the narrow band around the mesh surface where high resolution SDF samples are available. Outside
            of the narrow band, only low resolution samples are stored. Representing the narrow band thickness as a fraction
            of the mesh's bounding box diagonal length ensures that it is scale independent. A value of 0.01 is usually
            large enough. The smaller the narrow band thickness, the smaller the memory consumption of the sparse SDF.
            Range: [0, 1]
            Units: dimensionless"""
    )
    uniform int physxSDFMeshCollision:sdfResolution = 256 (
        displayName = "SDF Resolution"
        doc = """The spacing of the uniformly sampled SDF is equal to the largest AABB extent of the mesh, divided by the resolution.
            Choose the lowest possible resolution that provides acceptable performance; very high resolution results in
            large memory consumption, and slower cooking and simulation performance.
            Range: (1, inf)"""
    )
    uniform int physxSDFMeshCollision:sdfSubgridResolution = 6 (
        displayGroup = "Advanced"
        displayName = "SDF Subgrid Resolution"
        doc = """A positive subgrid resolution enables sparsity on signed-distance-fields (SDF) while a value of 0 leads
            to the usage of a dense SDF. A value in the range of 4 to 8 is a reasonable compromise between block size and 
            the overhead introduced by block addressing. The smaller a block, the more memory is spent on the address 
            table. The bigger a block, the less precisely the sparse SDF can adapt to the mesh's surface. In most cases 
            sparsity reduces the memory consumption of a SDF significantly. 
            Range: [0, inf)"""
    )
    uniform float physxSDFMeshCollision:sdfTriangleCountReductionFactor = 1 (
        displayGroup = "Advanced"
        displayName = "Triangle Count Reduction"
        doc = """Factor that quantifies the percentage of the input triangles to keep. 1 means the input triangle mesh does not
\t\tget modified. 0.5 would mean that the triangle count gets reduced to half the amount of the original mesh such that the
\t\tcollider needs to process less data. This helps to speed up collision detection at the cost of a small geometric error.
\t\tRange: [0, 1]
        Units: dimensionless"""
    )
}

class "PhysxSurfaceVelocityAPI" (
    doc = """PhysxSurfaceVelocityAPI enables surface velocity simulation
    that injects velocity to the solver through internal contact modify 
    callback. Surface velocity can be used typically for conveyer belt 
    simulation. It must be applied to a prim with UsdPhysicsRigidBodyAPI.
    """
)
{
    vector3f physxSurfaceVelocity:surfaceAngularVelocity = (0, 0, 0) (
        displayName = "Surface Angular Velocity"
        doc = """Surface angular velocity applied through contact modify callback.
        Units: degrees/second."""
    )
    vector3f physxSurfaceVelocity:surfaceVelocity = (0, 0, 0) (
        displayName = "Surface Linear Velocity"
        doc = """Surface linear velocity applied through contact modify callback. 
        Units: distance/second."""
    )
    bool physxSurfaceVelocity:surfaceVelocityEnabled = 1 (
        displayName = "Surface Velocity Enabled"
        doc = "Whether surface velocity is enabled or not."
    )
    bool physxSurfaceVelocity:surfaceVelocityLocalSpace = 1 (
        displayName = "Surface Velocity Local Space"
        doc = "Whether surface velocity is defined in body local space or in world space."
    )
}

class "PhysxMeshMergeCollisionAPI" (
    apiSchemas = ["CollectionAPI:collisionmeshes"]
    doc = """PhysxMeshMergeCollisionAPI enables implicit mesh merging of given meshes with respect to physics collision geometry representation. It is expected that this API extends the UsdPhysics.CollisionAPI definition, the UsdPhysics.CollisionAPI is still required to be present together with this API to define the collision properties.
    All meshes that belong to the collisionmeshes collection will be merged into one mesh that will
    be used for collision representation. Note that the collection can also define what meshes should be excluded from the selection. 
   
    This means that for example all meshes that belong to the collection will be represented
    as one convexHull rather than dozens of convexHulls per mesh.

    It is possible to collect meshes through the collection that do not belong to the same hierarchy. This is allowed,
    however if the collisions are part of a rigid body, the meshes that do not belong to the rigid body hierarchy wont move.
    As defined in the rigid body specification, only rigid body transformation is updated.

    Note that any changes to the meshes during runtime will get ignored.
    """
)
{
}

class "PhysxSceneQuasistaticAPI" (
    apiSchemas = ["CollectionAPI:quasistaticactors"]
    doc = """PhysxSceneQuasistaticAPI defines quasistatic mode for simulation.
    The API must be applied to a UsdPhysics.PhysicsScene prim.


    In this mode actors are simulated/moved by the physics engine by obeying
    external forces and constraints as usual, but they do not accumulate momentum.
    So that e.g. falling due to gravity is with constant speed, and motion stops
    as soon as external forces cease to apply. There is no conservation of momentum.    


    By default all actors belonging to the scene have this behavior unless the collection
    does have the includes defined, then the collection definition does have a precendence.
    """
)
{
    bool physxSceneQuasistatic:enableQuasistatic = 1 (
        displayName = "Enable Quasistatic"
        doc = "Whether the actors should behave quasistatic or not."
    )
}

class "PhysxMaterialAPI" (
    doc = "PhysX material extended parameters"
)
{
    bool physxMaterial:compliantContactAccelerationSpring = 0 (
        displayGroup = "Advanced"
        displayName = "Compliant Contact Acceleration Spring"
        doc = """If enabled, switches from force-based to acceleration-based compliant spring-damper contact effects.
        An acceleration-based spring-damper directly influences the acceleration of (rather than the force on) the contacting bodies,
        which makes the sink-in depth independent of the mass.
        The setting has no effect if compliant contacts are disabled, i.e., if the compliant contact stiffness is zero."""
    )
    float physxMaterial:compliantContactDamping = 0 (
        displayGroup = "Advanced"
        displayName = "Compliant Contact Damping"
        doc = """Damping coefficient for a compliant contact model using implicit springs. Ignored if compliant contacts
        are disabled (compliantContactStiffness is set to zero), in which case rigid contacts are active.
        Depending on the compliantContactAccelerationSpring setting, the damping is interpreted as a force or acceleration, respectively, per unit velocity.
            Range: [0, inf)
            Units:
                Force: force / (distance / seconds) = mass / seconds
                Acceleration: acceleration / (distance / seconds) = 1 / seconds"""
    )
    float physxMaterial:compliantContactStiffness = 0 (
        displayGroup = "Advanced"
        displayName = "Compliant Contact Stiffness"
        doc = """Spring stiffness for a compliant contact model using implicit springs. A higher stiffness results in behavior
        closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0.
        Depending on the compliantContactAccelerationSpring setting, the stiffness is interpreted as a force or acceleration, respectively, per unit distance.
            Range: [0, inf)
            Units:
                Force: force / distance = mass / seconds / seconds
                Acceleration: acceleration / distance = 1 / seconds / seconds """
    )
    uniform token physxMaterial:dampingCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        displayGroup = "Advanced"
        displayName = "Damping Combine Mode"
        doc = """Determines the way in which two material properties will be combined to yield a damping coefficient for a collision.
        This value is only relevant for compliant contact interactions."""
    )
    uniform token physxMaterial:frictionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        displayName = "Friction Combine Mode"
        doc = "Determines the way in which two material properties will be combined to yield a friction coefficient for a collision."
    )
    uniform token physxMaterial:restitutionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        displayName = "Restitution Combine Mode"
        doc = "Determines the way in which two material properties will be combined to yield a restitution coefficient for a collision."
    )
}

class PhysxPhysicsInstancer "PhysxPhysicsInstancer" (
    doc = "Core class for instancing physics prims"
)
{
    int[] physics:protoIndices (
        doc = """<b>Required property</b>. A list of instances to create from the prototypes
      defined in the prototypes relationship. Every entry represents an instance and
      the corresponding index value points to the prototype to create the instance from.
      For example, an entry of 1 results in an instance to be created of the prototype
      defined in prototypes[1]. <b>Topology attribute</b> - can be animated,
      but at a potential performance impact for streaming."""
    )
    rel physics:prototypes (
        doc = """<b>Required property</b>. Orders and targets the prototype root
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the
      PhysxPhysicsInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the protoIndices attribute to
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxPhysicsJointInstancer "PhysxPhysicsJointInstancer" (
    doc = """Class to instance physics joints from a set of prototype joints. The prototypes
    in the PhysxPhysicsInstancer base class (see prototypes relationship) are expected
    to be UsdPhysicsJoint prim types."""
)
{
    int[] physics:body0Indices (
        doc = """<b>Optional property</b>. Only applicable if body0s is a point instancer. 
      An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index].
      """
    )
    rel physics:body0s (
        doc = """<b>Required property</b>. The rel must contain either exactly one 
      UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage.
      If the rel is to a point instancer, the body0Indices must be specified. 
      """
    )
    int[] physics:body1Indices (
        doc = """<b>Optional property</b>. Only applicable if body1s is a point instancer. 
      An index specifies the per-instance body1 rel as the rigid body at the body1s-instancer's protoIndices[index].
      """
    )
    rel physics:body1s (
        doc = """<b>Required property</b>. The rel must contain either exactly one 
      UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage.
      If the rel is to a point instancer, the body1Indices must be specified.
      """
    )
    point3f[] physics:localPos0s (
        doc = """<b>Required property</b>. Per-instance localPos0. This transformation
      is added on top of the joint localPos0."""
    )
    point3f[] physics:localPos1s (
        doc = """<b>Required property</b>. Per-instance localPos1. This transformation
      is added on top of the joint localPos1."""
    )
    quath[] physics:localRot0s (
        doc = """<b>Required property</b>. Per-instance localRot0. This transformation
      is added on top of the joint localRot0."""
    )
    quath[] physics:localRot1s (
        doc = """<b>Required property</b>. Per-instance localRot1. This transformation
      is added on top of the joint localRot1."""
    )
    int[] physics:protoIndices (
        doc = """<b>Required property</b>. A list of instances to create from the prototypes
      defined in the prototypes relationship. Every entry represents an instance and
      the corresponding index value points to the prototype to create the instance from.
      For example, an entry of 1 results in an instance to be created of the prototype
      defined in prototypes[1]. <b>Topology attribute</b> - can be animated,
      but at a potential performance impact for streaming."""
    )
    rel physics:prototypes (
        doc = """<b>Required property</b>. Orders and targets the prototype root
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the
      PhysxPhysicsInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the protoIndices attribute to
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxPhysicsGearJoint "PhysxPhysicsGearJoint" (
    doc = "A gear joint connects two existing revolute (a.k.a. hinge) joints and constrains the angular velocities of involved rigid bodies. If omega0 is the angular velocity of the first rigid body around the PhysicsRevoluteJoint axis, omega1 is the angular velocity of the second rigid body around the PhysicsRevoluteJoint axis, and R is the gear ratio, then the enforced constraint is abs(omega1) = abs(omega0) * R. The equation is valid for the absolute values of angular velocities. The angular velocities may otherwise have opposite signs, depending on the orientations of the joint frames. Gear joints can be used with GPU simulation but in that case these specific joints will run through the CPU pipeline. If a gear joint is created between articulation revolute joints, excludeFromArticulation must be set to true for the gear joint itself, otherwise an error occurs. To include the gear joint in the articulation itself, please use PhysxMimicJointAPI instead to implement a gear joint. A known limitation is that current implementation does not work for planetary gears."
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    float physics:gearRatio = 1 (
        displayName = "Gear Ratio"
        doc = """Gear ratio. For two gears with N0 and N1 teeth respectively, the gear ratio should be N0/N1.
            Range: (-inf, inf)
            Units: dimensionless"""
    )
    rel physics:hinge0 (
        displayName = "Hinge 0"
        doc = "Relationship to first hinge joint. It should be a PhysicsRevoluteJoint. It is mandatory to define one (and only one) relationship here."
    )
    rel physics:hinge1 (
        displayName = "Hinge 1"
        doc = "Relationship to second hinge joint. It should be a PhysicsRevoluteJoint. It is mandatory to define one (and only one) relationship here."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxPhysicsRackAndPinionJoint "PhysxPhysicsRackAndPinionJoint" (
    doc = "A rack-and-pinion joint connects an existing revolute/hinge joint to an existing prismatic joint, and constrains the angular and linear velocities of involved rigid bodies. If omega is the angular velocity of the pinion rigid body around the PhysicsRevoluteJoint axis, V is the linear velocity of the rack rigid body along the PhysicsPrismaticJoint axis, and R is the ratio, then the enforced constraint is abs(omega) = abs(V) * R. The equation is valid for the absolute values of velocities. The velocities may otherwise have opposite signs, depending on the orientations of the joint frames. Rack-and-pinion joints can be used with GPU simulation but in that case these specific joints will run through the CPU pipeline. If a rack-and-pinion joint is created between articulation joints, excludeFromArticulation must be set to true for the rack-and-pinion joint itself, otherwise an error occurs. To include the rack-and-pinion joint in the articulation itself, please use PhysxMimicJointAPI instead to implement a rack-and-pinion joint."
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    rel physics:hinge (
        displayName = "Hinge"
        doc = "Relationship to the hinge joint. It should be a PhysicsRevoluteJoint. It is mandatory to define one (and only one) relationship here."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel physics:prismatic (
        displayName = "Prismatic"
        doc = "Relationship to the prismatic joint. It should be a PhysicsPrismaticJoint. It is mandatory to define one (and only one) relationship here."
    )
    float physics:ratio = 1 (
        displayName = "Ratio"
        doc = """Ratio between angular and linear motion. For a rack of length L with N0 teeth and a pinion of N1 teeth, the ratio should be (PI * 2 * N0)/(L * N1).
            Range: (-inf, inf)
            Units: degrees / distance"""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "PhysxJointAPI" (
    doc = """PhysX joint extended parameters. Can be applied to a PhysicsJoint prim or
          the derived classes PhysicsRevoluteJoint, PhysicsPrismaticJoint or PhysicsSphericalJoint."""
)
{
    float physxJoint:armature = 0 (
        displayGroup = "Advanced"
        displayName = "Armature"
        doc = """Conceptually, armature represents the inertia of an actuator driving the joint. It is an artificial mass/inertia
            that is added to the joint-space inertia and can help stabilize an articulation. Note that this parameter is used only
            when the joint belongs to an articulation (see PhysicsArticulationRootAPI). Furthermore, note that for a joint with
            multiple degrees of freedom (like a PhysicsSphericalJoint), the specified armature will be applied to each of the
            corresponding axes individually.
            Range: [0, inf)
            Units: Linear joint - mass
                   Angular joint - mass * distance^2"""
    )
    float physxJoint:jointFriction = 0 (
        displayGroup = "Advanced"
        displayName = "Joint Friction"
        doc = """Joint friction. Only applies to joints that are part of an articulation (see PhysicsArticulationRootAPI).
            All joint axes will use the same friction value.
            
            The joint friction is unitless and relates the magnitudes of the linear force vector F and torque vector T
            transmitted from parent to child link to the maximal friction force F_resist that may be applied by the solver
            to resist joint motion, per axis; i.e. |F_resist| <= coefficient * (|F| + |T|), where F_resist may refer to a
            linear force or torque depending on the joint axis (linear vs. angular). The simulated friction effect is
            therefore similar to static and Coulomb friction. In order to simulate dynamic joint friction, a joint drive
            (see PhysicsDriveAPI) with zero stiffness and zero velocity target, and an appropriately dimensioned damping
            parameter should be used.
        
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxJoint:maxJointVelocity = 1000000 (
        displayGroup = "Advanced"
        displayName = "Maximum Joint Velocity"
        doc = """Maximum joint velocity. Only applies to joints that are part of an articulation (see PhysicsArticulationRootAPI).
            All joint axes will use the same maximum joint velocity value.
            
            The solver will apply appropriate joint-space impulses in order to enforce the per-axis joint-velocity limit.
        
            Range: [0, inf)
            Units: Linear joint - distance / seconds
                   Angular joint - degrees / seconds"""
    )
}

class "PhysxPhysicsDistanceJointAPI" (
    doc = "PhysX distance joint extended parameters. Can be applied to a PhysicsDistanceJoint prim."
)
{
    float physxPhysicsDistanceJoint:springDamping = 0 (
        displayName = "Spring Damping"
        doc = """Spring damping to use to resolve violation of the specified joint distance range. Will be ignored
            unless springEnabled is set to true. See attribute springStiffness for details.
            Range: [0, inf)
            Units: force * seconds / distance = mass / seconds"""
    )
    bool physxPhysicsDistanceJoint:springEnabled = 0 (
        displayName = "Spring Enabled"
        doc = """If enabled, a spring/damper, i.e., soft constraint, will be used to maintain the desired
              distance range defined by the joint. The soft constraint will only be active when the distance
              between the joint frame origins is below minDistance or above maxDistance (see PhysicsDistanceJoint)."""
    )
    float physxPhysicsDistanceJoint:springStiffness = 0 (
        displayName = "Spring Stiffness"
        doc = """Spring stiffness to use to resolve violation of the specified joint distance range. Will be ignored
            unless springEnabled is set to true. The applied force will be proportional to the length by which the distance
            range is violated. Let the violation be defined as geometricError = actualDistance - maxDistance
            if actualDistance > maxDistance, and geometricError = actualDistance - minDistance if actualDistance < minDistance.
            In addition, a damping term can be specified (see attribute springDamping) such that the applied force can be
            roughly defined as:
            F = (springStiffness * geometricError) - (springDamping * jointVelocity).
            Note that an implicit time-stepping scheme will be used to compute the force.
            Range: [0, inf)
            Units: force / distance = mass / seconds / seconds"""
    )
}

class "PhysxLimitAPI" (
    doc = """PhysX joint limit extended parameters. Can be applied to a prim that has PhysicsLimitAPI applied.
          Note that this schema is only supported for joints that are NOT part of an articulation
          (see PhysicsArticulationRootAPI). PhysxLimitAPI is a multipleApply schema and supports the same set
          of schema instance names as PhysicsLimitAPI. The instance name used for the PhysxLimitAPI schema should
          match the one used for the corresponding PhysicsLimitAPI."""
)
{
    float physxLimit:__INSTANCE_NAME__:bounceThreshold = 0 (
        displayName = "Bounce Threshold"
        doc = """Determines the minimum impact velocity which will cause the joint to bounce off the limit. Only relevant
            if the restitution attribute is larger than zero. If the threshold is not reached, hitting the limit will be
            treated as if restitution was zero. See restitution for more details on bounce behavior.
            Range: [0, inf)
            Units: 
                if linear: distance / seconds
                if angular: degrees / seconds"""
    )
    float physxLimit:__INSTANCE_NAME__:damping = 0 (
        displayName = "Damping"
        doc = """Damping for spring-damper limit dynamics. If greater than zero, the limit is soft,
            i.e. a spring pulls the joint back to the limit. See the documentation of the stiffness attribute for details.
            Range: [0, inf)
            Units: 
                if linear: force * seconds / distance = mass / seconds
                if angular: torque * seconds / degrees = mass * distance * distance / seconds / degrees"""
    )
    float physxLimit:__INSTANCE_NAME__:restitution = 0 (
        displayName = "Restitution"
        doc = """Controls the amount of bounce when the joint hits a limit. The dynamics solver will target a post simulation
            velocity of: restitution * -v (v = velocity along the joint axes).
            Note that restitution/bounce can not be combined with the stiffness/damping attributes. Either the limit is a hard
            constraint and restitution>=0, stiffness=0, damping=0 or the limit is a soft constraint and restitution=0, (stiffness>0
            or damping>0)
            Range: [0, 1]
            Units: dimensionless"""
    )
    float physxLimit:__INSTANCE_NAME__:stiffness = 0 (
        displayName = "Stiffness"
        doc = '''Spring stiffness for spring-damper limit dynamics. If greater than zero, the limit is soft, 
            i.e. a spring pulls the joint back to the limit. Can not be used in combination with restitution>0
            (for details see the docu on restitution). The applied force will be proportional to the length/angle
            by which the limit is violated. Let the violation be defined as geometricError = jointPosition - highLimit
            if jointPosition > highLimit, and geometricError = jointPosition - lowLimit if jointPosition < lowLimit
            (jointPosition being an angle in the case of an angular joint axis). In addition, a damping term can be
            specified (see attribute damping) such that the applied force can be roughly defined as:
            F = (stiffness * geometricError) - (damping * jointVelocity).
            Note that an implicit time-stepping scheme will be used to compute the force.
            The soft constraint will only be active when the distance/angle between the joint frame
            origins/orientations is below the "low" limit value or above the "high" limit value (see PhysicsLimitAPI).
            Range: [0, inf)
            Units: 
                if linear: force / distance = mass / seconds / seconds
                if angular: torque / degrees = mass * distance * distance / seconds / seconds / degrees'''
    )
}

class "PhysxResidualReportingAPI" (
    doc = """Gives access to residual values that inform about the remaining physics solver error present 
\t\tduring the last position and during the last velocity iteration. The residual reporting must be enabled 
\t\ton the Physics Scene, otherwise the reported values will be zero. The API can be applied to either:
\t\t- Joints. The joint residual will be reported.
\t\t- Articulation Roots. The RMS (root mean squared) and max value over all articulation joint residuals will be reported.
\t\t- Physics Scene. The RMS and max value over all error/residual sources (including contacts) will be reported."""
)
{
    float physxResidualReporting:maxResidualPositionIteration = 0 (
        displayName = "Max Residual Position Iteration"
        doc = """The maximal magnitude of the physics solver error during the last position iteration.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxResidualReporting:maxResidualVelocityIteration = 0 (
        displayName = "Max Residual Velocity Iteration"
        doc = """The maximal magnitude of the physics solver error during the last velocity iteration.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxResidualReporting:rmsResidualPositionIteration = 0 (
        displayName = "RMS Residual Position Iteration"
        doc = """The RMS (root mean squared) magnitude of the physics solver error during the last position iteration.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxResidualReporting:rmsResidualVelocityIteration = 0 (
        displayName = "RMS Residual Velocity Iteration"
        doc = """The RMS (root mean squared) magnitude of the physics solver error during the last velocity iteration.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysicsJointStateAPI" (
    doc = '''The PhysicsJointStateAPI allows reading and modifying position and velocity of a specific articulation joint axis.
    It can be applied only to the following joint primitives when they are part of an articulation:
    - UsdPhysicsJoint
    - UsdPhysicsRevoluteJoint
    - UsdPhysicsPrismaticJoint

    The PhysicsJointStateAPI is a multipleApply schema, and its instance name TfToken defines the joint axis.
    For multi degrees-of-freedom joints, the instance names to choose from are: "transX", "transY", "transZ", "rotX", "rotY", "rotZ".
    For prismatic joints, the name "linear" has to be used.
    For revolute joints, the name "angular" has to be used.
    '''
)
{
    float state:__INSTANCE_NAME__:physics:position = 0 (
        displayName = "Position"
        doc = """Joint state position defines the relative difference expressed as a distance or angle between articulation joint body0 frame and articulation joint body1 frame.
            
            For UsdPhysicsPrismaticJoint it's the linear distance between body0 and body1 along the axis specified by the joint itself.
            For UsdPhysicsRevoluteJoint it's the angular difference between body0 and body1 frames along the axis specified by the joint itself.
            For UsdPhsyicsJoint joints it's the angular or linear difference between body0 and body1 frames along the axis specified by the multiple apply schema instance name.

            When writing to the position attribute, the changes are immediately reflected on the next simulation step, instantaneously teleporting articulation links to the wanted position.

            After a simulation step, the position value will reflect the actual last position of the joint, that may have been affected by other mechanisms such as drives.

            Range: (-inf, inf)
            Units: 
                if linear: distance
                if angular: degrees"""
    )
    float state:__INSTANCE_NAME__:physics:velocity = 0 (
        displayName = "Velocity"
        doc = """Joint state velocity defines the relative velocity between joint body0 and joint body1 along the specified joint axis.

            For UsdPhysicsPrismaticJoint it's the relative linear velocitity of body0 relative to body1 along the axis specified by the joint itself.
            For UsdPhysicsRevoluteJoint it's the  relative angular velocitity of body0 relative to body1 along the axis specified by the joint itself.
            For UsdPhsyicsJoint joints it's the relative angular or linear velocitity of body0 relative to body1 along the axis specified by the multiple apply schema instance name.

            When writing to the velocity attribute, the changes are immediately reflected on the next simulation step, instantaneously changing velocity to the wanted value.

            After a simulation step, the velocity value will reflect the actual last velocity of the joint, that may have been affected by other mechanisms such as drives.

            Range: (-inf, inf)
            Units: 
                if linear: distance / seconds
                if angular: degrees / seconds"""
    )
}

class "PhysxArticulationAPI" (
    doc = "PhysX articulation extended parameters"
)
{
    bool physxArticulation:articulationEnabled = 1 (
        displayName = "Articulation Enabled"
        doc = "Boolean defining whether articulation is enabled or disabled."
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        displayName = "Self Collisions Enabled"
        doc = "Boolean defining whether self collisions should be enabled or disabled."
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        displayName = "Sleep Threshold"
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf)
            Default: 0.00005 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        displayName = "Solver Position Iteration Count"
        doc = "Solver position iteration counts for the body. Allowed range [1, 255]."
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        displayName = "Solver Velocity Iteration Count"
        doc = "Solver velocity iteration counts for the body. Allowed range [0, 255]."
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        displayName = "Stabilization Threshold"
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf)
            Default: 0.00001 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxForceAPI" (
    doc = """PhysX schema API that applies a force and torque to a rigid body 
    (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI). The API can be applied to either:
    - The rigid-body Xformable, in which case the force is applied at the body's center of mass.
    - To an UsdGeom.Xformable that is a child of the rigid-body Xformable, 
    in which case the force is applied at the location defined by the Xformable.

    The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. 
    Note that any scale transform operations will only affect the force and torque values if on \"acceleration\" mode."""
)
{
    vector3f physxForce:force = (0, 0, 0) (
        displayName = "Force"
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled. The force is applied at the position
            defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied
            directly to a rigid-body Xformable.
            Range: (-inf, inf)
            Units:
                Force: mass * distance / seconds / seconds
                Acceleration:  distance / seconds / seconds"""
    )
    bool physxForce:forceEnabled = 1 (
        displayName = "Force Enabled"
        doc = "Boolean defining whether the force and torque are enabled or disabled."
    )
    uniform token physxForce:mode = "acceleration" (
        allowedTokens = ["force", "acceleration"]
        displayName = "Mode"
        doc = "Force mode, can be either a force or an acceleration."
    )
    vector3f physxForce:torque = (0, 0, 0) (
        displayName = "Torque"
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled. For units see mode attribute.
            Range: (-inf, inf)
            Units:
                Force: mass * distance * distance / seconds / seconds
                Acceleration:  degrees / seconds / seconds"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        displayName = "World Frame Enabled"
        doc = "Boolean defining whether the force and torque are in world frame or in local frame."
    )
}

class "PhysxCharacterControllerAPI" (
    doc = "PhysxCharacterControllerAPI can be applied to a capsuleGeom. It will turn the capsule into a character controller."
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        allowedTokens = ["easy", "constrained"]
        displayName = "Climb Mode"
        doc = "The climbing mode."
    )
    float physxCharacterController:contactOffset = 0.1 (
        displayName = "Contact Offset"
        doc = """The contact offset used by the controller.
            Range: [0, inf)
            Units: distance"""
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        displayName = "Invisible Wall Height"
        doc = """Height of invisible walls created around non-walkable triangles.
            Range: [0, inf)
            Units: distance"""
    )
    float physxCharacterController:maxJumpHeight = 0 (
        displayName = "Max Jump Height"
        doc = """Maximum height a jumping character can reach.
            Range: [0, inf)
            Units: distance"""
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        displayName = "Move Target"
        doc = "Desired target position that CCT should try to reach."
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        displayName = "Non Walkable Mode"
        doc = "The non-walkable mode controls if a character controller slides or not on a non-walkable part."
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        displayName = "Scale Coefficient"
        doc = """Scale coefficient for underlying kinematic actor.
            Range: [0, inf)
            Units: dimensionless"""
    )
    rel physxCharacterController:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this character controller.
        By default, this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )
    float physxCharacterController:slopeLimit = 0.3 (
        displayName = "Slope Limit"
        doc = """Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. 
        A value of 0 disables this feature."""
    )
    float physxCharacterController:stepOffset = 0.5 (
        displayName = "Step Offset"
        doc = """Defines the maximum height of an obstacle which the character can climb.
            Range: [0, inf)
            Units: distance"""
    )
    uniform token physxCharacterController:upAxis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        displayName = "Up Axis"
        doc = "Up axis for stepping functionality."
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        displayName = "Volume Growth"
        doc = """Cached volume growth.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysxTriggerAPI" (
    doc = "PhysX trigger"
)
{
    uniform token physxTrigger:enterScriptType = "scriptFile" (
        allowedTokens = ["scriptFile"]
        displayName = "Enter Script Type"
        doc = "Enter script type. Script file tries to find a file on disc and execute."
    )
    uniform token physxTrigger:leaveScriptType = "scriptFile" (
        allowedTokens = ["scriptFile"]
        displayName = "Leave Script Type"
        doc = "Leave script type. Script file tries to find a file on disc and execute."
    )
    uniform token physxTrigger:onEnterScript (
        displayName = "On Enter Script"
        doc = "Enter script."
    )
    uniform token physxTrigger:onLeaveScript (
        displayName = "On Leave Script"
        doc = "Leave script."
    )
}

class "PhysxTriggerStateAPI" (
    doc = "PhysX trigger state"
)
{
    rel physxTrigger:triggeredCollisions (
        displayName = "Triggered Collisions"
        doc = "List of collisions that are currently triggered."
    )
}

class "PhysxCookedDataAPI" (
    doc = "PhysX cooked data storage."
)
{
    uchar[] physxCookedData:__INSTANCE_NAME__:buffer
}

class "PhysxTendonAxisAPI" (
    doc = """WARNING: Draft API, this design is not fixed and may change in the future. At this point, we don't support
    multi-axis joints (e.g. spherical, D6).
    
    Applied to a Physics Joint that must be part of an articulation, e.g. PhysicsRevoluteJoint or PhysicsPrismaticJoint.
    
    A tendon axis is part of a fixed tendon and contributes to the tendon length via the position of its associated
    articulation joint axis and the gearing attribute. The tendon applies spring-damper forces to the articulation links,
    scaled by the force coefficient, that aim to maintain constraints on the tendon lengths.
    
    A joint may have multiple tendon axes that belong to distinct fixed tendons; therefore, the fixed-tendon APIs are
    multi-apply and are grouped into tendons by their instance names.
    
    Fixed tendons do not allow linking arbitrary joint axes of the articulation: The respective joints must all be
    directly connected to each other in the articulation structure, i.e. each of the joints in the tendon must be
    connected by a single articulation link to another joint in the same tendon. This implies that fixed tendons can
    branch along with a branching articulation as well. In addition, the root tendon axis created by applying the
    PhysxTendonAxisRootAPI must be applied to the articulation joint that is the common ancestor of all joint
    axes in the fixed tendon.
    
    In a future version, it will be possible to include multiple axes of a multi-axis joint (e.g. a spherical joint)
    in the fixed tendon by adding them to the axis token array, and setting their gearing and forceCoefficient accordingly
    in the respective float arrays (in the same order). Until then, the jointAxis token array is ignored, and only the first
    element of the gearing array is considered.
    """
)
{
    float[] physxTendon:__INSTANCE_NAME__:forceCoefficient = [1] (
        displayName = "Force Coefficient"
        doc = """Joint force coefficient(s) per joint axis in axis token array, in the same order.
            Range: (-inf, inf)
            Units: 
                if translational axis: unitless
                if rotational axis: distance"""
    )
    float[] physxTendon:__INSTANCE_NAME__:gearing = [1] (
        displayName = "Gearing"
        doc = """Joint gearing(s) per joint axis in axis token array, in the same order.
            Range: (-inf, inf)
            Units: 
                if translational axis: unitless
                if rotational axis: distance/degrees"""
    )
    uniform token[] physxTendon:__INSTANCE_NAME__:jointAxis (
        allowedTokens = ["transX", "transY", "transZ", "rotX", "rotY", "rotZ"]
        displayName = "Joint Axis"
        doc = "Specifies target joint axis/axes. Ignored when the joint only has a single axis, e.g. a revolute joint."
    )
}

class "PhysxTendonAxisRootAPI" (
    apiSchemas = ["PhysxTendonAxisAPI:__INSTANCE_NAME__"]
    doc = """WARNING: Draft API, this design is not fixed and may change in the future. At this point, we don't support
    multi-axis joints (e.g. spherical, D6) yet.
    
    Applied to a Physics Joint that must be part of an articulation, e.g. PhysicsRevoluteJoint or PhysicsPrismaticJoint.
    
    In addition to creating a regular axis of the fixed tendon, the root API provides attributes that apply to the
    entire tendon. The root API must be applied to the joint that is the common ancestor of all joint axes in the tendon.
    
    For restrictions on tendon structure and grouping of axes into tendons, see PhysxTendonAxisAPI.
    """
)
{
    float physxTendon:__INSTANCE_NAME__:damping = 0 (
        displayName = "Damping"
        doc = """Tendon length damping.
            Range: [0, inf)
            Units: force / distance * time = mass / time"""
    )
    float physxTendon:__INSTANCE_NAME__:limitStiffness = 0 (
        displayName = "Limit Stiffness"
        doc = """Tendon length-limit spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    float physxTendon:__INSTANCE_NAME__:lowerLimit = -inf (
        displayName = "Lower Limit"
        doc = """Tendon length lower limit.
            Range: (-inf, upperLimit].
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:offset = 0 (
        displayName = "Offset"
        doc = """Tendon length offset.
            Range: (-inf, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:restLength = 0 (
        displayName = "Rest Length"
        doc = """Tendon rest length.
            Range: (-inf, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:stiffness = 0 (
        displayName = "Stiffness"
        doc = """Tendon length spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    bool physxTendon:__INSTANCE_NAME__:tendonEnabled = 1 (
        displayName = "Tendon Enabled"
        doc = "Enables/disables the tendon from contributing to the articulation dynamics."
    )
    float physxTendon:__INSTANCE_NAME__:upperLimit = inf (
        displayName = "Upper Limit"
        doc = """Tendon length upper limit.
            Range: [lowerLimit, inf)
            Units: distance"""
    )
}

class "PhysxTendonAttachmentAPI" (
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.
    
    Applied to an articulation-link rigid-body Xformable.
    
    A tendon attachment is part of a spatial tendon and is attached to an articulation link. The distance between the
    attachment and its parent attachment contributes to the length of the tendon, after scaling by the gearing
    attribute.

    The localPos attribute defines the translational offset of the attachment in the link's local frame; in particular,
    this means that the offset is scaled together with any scaling applied to the link.
    
    An articulation link may have multiple distinct attachments that belong to the same or distinct spatial tendons;
    therefore, the spatial tendon APIs are multi-apply and each attachment must have a unique instance name that is
    used in parent-child relationships of the attachments."""
)
{
    float physxTendon:__INSTANCE_NAME__:gearing = 1 (
        displayName = "Gearing"
        doc = """Attachment distance scaling factor.
            Range: (-inf, inf)
            Units: unitless"""
    )
    point3f physxTendon:__INSTANCE_NAME__:localPos = (0, 0, 0) (
        displayName = "Local Position"
        doc = """Location of the attachment. Only considered if API is applied to an articulation link (i.e. with a PhysicsRigidBodyAPI).
            Units: distance (local-frame)"""
    )
    uniform token physxTendon:__INSTANCE_NAME__:parentAttachment (
        displayName = "Parent Attachment"
        doc = "API instance name of parent attachment at parentLink."
    )
    rel physxTendon:__INSTANCE_NAME__:parentLink (
        displayName = "Parent Link"
        doc = "Relationship to parent link that has a PhysxTendonAttachmentAPI or PhysxTendonAttachmentRootAPI with instance name parentAttachment applied."
    )
}

class "PhysxTendonAttachmentRootAPI" (
    apiSchemas = ["PhysxTendonAttachmentAPI:__INSTANCE_NAME__"]
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.

    Applied to an articulation-link rigid-body Xformable.

    The root API creates a new spatial tendon tree. The root tendon attachment is the only attachment in a tendon tree
    that does not have a parent, so the parentLink, parentAttachment, and gearing attributes inherited from
    PhysxTendonAttachmentAPI are ignored for a root.

    Spatial tendons create line-of-sight distance constraints between links of a single articulation. In particular,
    spatial tendons run through attachments that are positioned relative to a rigid-body link, and their length is
    defined as a weighted sum of the distance between the attachments in the tendon.

    Spatial tendons may branch, in which case the tendon splits up into multiple conceptual sub-tendons, one for each
    root-to-leaf path in the tendon tree. The tendon tree starts at the root, and its topology is defined by the
    attachments' parentLink rel and parentAttachment token.

    It is possible to create multiple attachments per link, see PhysxTendonAttachmentAPI.

    Details on dynamics:

    The length of a sub-tendon in the tree is

    subTendonLength = sum(gearing[i] * |p[i] - p_parent[i]|)

    where the sum is evaluated along the unique tree path between root and leaf. The gearing[i] is the i-th attachment's
    gearing, and |p[i] - p_parent[i]| is the distance between the positions of the i-th attachment and its parent
    attachment.

    Each subtendon has spring-damper dynamics acting on the length constraint

    constraint = 0 = offset + subTendonLength - restLength

    where the offset is a common summand for all sub-tendons of a spatial tendon, and the restLength is specific to a
    sub-tendon, see the PhysxTendonAttachmentLeafAPI.

    If limits are not active, the sub-tendon force that acts on the leaf is

    F = stiffness * constraint + damping * tendonVelocity

    where tendonVelocity is the sum of the time derivatives of the line-of-sight distances between
        1) the leaf and its parent attachment and
        2) the tendon root and its first child attachment on the path to the leaf.
    Stiffness and damping are common parameters for all sub-tendons.

    The 3D force applied at the leaf attachment is equal to 

    F * (p_parent - p_leaf).

    where p_leaf and p_parent are the leaf's position and its parent's position, respectively. The reaction force acting
    on the root attachment is

    F * (p_child_leaf - p_root)

    where p_child_leaf is the position of the root's child attachment that leads to the leaf that produces F,
    and p_root is the root attachment position. The tendon force is not further propagated through the tendon, so at
    intermediate attachments (i.e. created by PhysxTendonAttachmentAPI) no forces are applied.

    Note that a spatial tendon may both pull and push on the leaf and root attachments. A string-like, one-sided constraint
    can be implemented using the sub-tendon's length limits.

    Sub-tendon length limits constrain the offset length

    lowerLimit <= subTendonLength + offset<= upperLimit

    and, when active, add a restoring spring force parametrized by limitStiffness to the tendon force, analogous to the
    length constraint force above. Limit dynamics are damped by the tendon-length damping that is applied regardless of
    a limit being active. Limit parameters are attributes of the PhysxTendonAttachmentLeafAPI."""
)
{
    float physxTendon:__INSTANCE_NAME__:damping = 0 (
        displayName = "Damping"
        doc = """Common sub-tendon length damping.
            Range: [0, inf)
            Units: force / distance * time = mass / time"""
    )
    float physxTendon:__INSTANCE_NAME__:limitStiffness = 0 (
        displayName = "Limit Stiffness"
        doc = """Common sub-tendon length-limit spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    float physxTendon:__INSTANCE_NAME__:offset = 0 (
        displayName = "Offset"
        doc = """Common sub-tendon length offset.
            Range: (-inf, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:stiffness = 0 (
        displayName = "Stiffness"
        doc = """Common sub-tendon length spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    bool physxTendon:__INSTANCE_NAME__:tendonEnabled = 1 (
        displayName = "Tendon Enabled"
        doc = "Enables/disables the tendon from contributing to the articulation dynamics."
    )
}

class "PhysxTendonAttachmentLeafAPI" (
    apiSchemas = ["PhysxTendonAttachmentAPI:__INSTANCE_NAME__"]
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.
    
    Applied to an articulation-link rigid-body Xformable.
    
    The leaf API creates a new sub-tendon between the leaf and the root attachment. A leaf cannot have any children,
    i.e. there cannot be another attachment API that refers to a leaf as parent."""
)
{
    float physxTendon:__INSTANCE_NAME__:lowerLimit = -inf (
        displayName = "Lower Length Limit"
        doc = """Sub-tendon length lower limit.
            Range: (-inf, upperLimit]
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:restLength = -inf (
        displayName = "Rest Length"
        doc = """Sub-tendon rest length. If set to a negative value, the rest length is computed internally from the articulation pose and the attachment positions at simulation start.
            Range: [0, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:upperLimit = inf (
        displayName = "Upper Length Limit"
        doc = """Sub-tendon length upper limit.
            Range: [lowerLimit, inf)
            Units: distance"""
    )
}

class "PhysxMimicJointAPI" (
    doc = '''Applied to a Physics Joint that must be part of an articulation. Supported joint types are:
          PhysicsRevoluteJoint (with a limit set), PhysicsPrismaticJoint as well as the more generic
          PhysicsJoint if all linear degrees of freedom are locked.
          
          This schema allows to interconnect the degrees of freedom of two joints according to the relationship:
          jointPosition + (gearing * referenceJointPosition) + offset = 0. This can be used to have, for example,
          one joint mimic the motion of another joint. The term "position" does not necessarily mean a translational
          unit, in the case of an angular degree of freedom it is an angle. The mimic joint operates on a single
          degree of freedom which is specified through the instance name of this multiple apply schema. The allowed
          instance name tokens are "rotX", "rotY" and "rotZ". See the documentation of the attribute referenceJointAxis
          for more info related to specifying the degree of freedom to operate on. Notes: 1) the two joints have to
          be part of the same articulation. 2) once the simulation has started, a significant performance penalty will
          be incurred if a mimic joint is added or removed, if the referenceJoint relationship is changed or if the
          referenceJointAxis attributes is modified. 3) the mimic joint relationship is interpreted as a two-way
          interaction and an impulse will get applied to the reference joint as well.'''
)
{
    float physxMimicJoint:__INSTANCE_NAME__:gearing = 1 (
        displayName = "Gearing"
        doc = """The gearing coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
              Range: (-inf, inf)
              Units: 
                    if linear to angular: degrees / distance
                    if angular to linear: distance / degrees
                    Otherwise the value is unitless"""
    )
    float physxMimicJoint:__INSTANCE_NAME__:offset = 0 (
        displayName = "Offset"
        doc = """The offset coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
              Range: (-inf, inf)
              Units: distance or degrees (depending on whether the mimic joint's degree of freedom is linear or angular)"""
    )
    rel physxMimicJoint:__INSTANCE_NAME__:referenceJoint (
        displayName = "Reference Joint"
        doc = """The joint that shall be mimicked. Relationship to a prim that has the PhysicsJoint API schema
              applied. For the supported joint types, see the general documentation of PhysxMimicJointAPI. The
              reference joint as well as the joint that mimics the reference joint have to be part of the same
              articulation (see PhysicsArticulationRootAPI)."""
    )
    uniform token physxMimicJoint:__INSTANCE_NAME__:referenceJointAxis = "rotX" (
        allowedTokens = ["rotX", "rotY", "rotZ"]
        displayName = "Reference Joint Axis"
        doc = """The axis that marks the degree of freedom of the reference joint to mimic. Has to be a valid
              degree of freedom on the reference joint. For joint types with a single degree of freedom
              (like PhysicsRevoluteJoint or PhysicsPrismaticJoint), this attribute will be ignored since the
              axis is defined implicitly. The mimic joint connects <targetJoint, targetJointAxis> to
              <referenceJoint, referenceJointAxis> with targetJoint being the prim that has PhysxMimicJointAPI
              applied and targetJointAxis being defined through the instance name token of PhysxMimicJointAPI."""
    )
}

class "PhysxVehicleContextAPI" (
    doc = "PhysX vehicles general settings. Has to be applied to a PhysicsScene prim."
)
{
    float3 physxVehicleContext:forwardAxis (
        displayName = "Forward Axis"
        doc = """Deprecated. Please use longitudinalAxis instead.
              
              The normalized vector defining the general forward direction to use for vehicles.
              Has to match one of the base axes (1,0,0), (0,1,0) etc. Arbitrary axes are not
              supported.

              Note: will be ignored if longitudinalAxis is used."""
    )
    uniform token physxVehicleContext:longitudinalAxis = "undefined" (
        allowedTokens = ["posX", "negX", "posY", "negY", "posZ", "negZ", "undefined"]
        displayName = "Longitudinal Axis"
        doc = '''The axis defining the general forward direction to use for vehicles.

              Note: the "undefined" token value is only a valid option for indicating that the
              deprecated attribute forwardAxis should be used instead. Else, a valid axis has to
              be chosen.'''
    )
    float3 physxVehicleContext:upAxis (
        displayName = "Up Axis"
        doc = """Deprecated. Please use verticalAxis instead.
              
              The normalized vector defining the general up direction to use for vehicles.
              Has to match one of the base axes (1,0,0), (0,1,0) etc. Arbitrary axes are not
              supported.

              Note: will be ignored if verticalAxis is used."""
    )
    uniform token physxVehicleContext:updateMode = "velocityChange" (
        allowedTokens = ["velocityChange", "acceleration"]
        displayName = "Update Mode"
        doc = """The dynamics of the vehicle simulation can get applied to the PhysX rigid 
              body by either applying an acceleration or by using a velocity delta."""
    )
    uniform token physxVehicleContext:verticalAxis = "undefined" (
        allowedTokens = ["posX", "negX", "posY", "negY", "posZ", "negZ", "undefined"]
        displayName = "Vertical Axis"
        doc = '''The axis defining the general up direction to use for vehicles.

              Note: the "undefined" token value is only a valid option for indicating that the
              deprecated attribute upAxis should be used instead. Else, a valid axis has to be
              chosen.'''
    )
}

class PhysxVehicleTireFrictionTable "PhysxVehicleTireFrictionTable" (
    doc = "Table defining the friction values of a tire against a given set of ground materials."
)
{
    float defaultFrictionValue = 1 (
        displayName = "Default Friction Value"
        doc = """The friction value to use for the tire against the ground if the material of the ground surface is not among the materials
        listed in groundMaterials. The value has to be greater or equal 0."""
    )
    float[] frictionValues (
        displayName = "Friction Values"
        doc = "The friction values to use for the tire against the ground materials listed under groundMaterials. The array needs to have the same size as the list of materials specified in groundMaterials."
    )
    rel groundMaterials (
        displayName = "Ground Materials"
        doc = "Relationships to Material instances that have PhysicsMaterialAPI applied. For each material, a friction value has to be specified in the frictionValues attribute. If a material is encountered that has not been listed, the value declared in defaultFrictionValue will be used."
    )
}

class "PhysxVehicleWheelAPI" (
    doc = """Properties of a PhysX vehicle wheel. If the wheel setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI applied.
             If the intent is to share the wheel setup, PhysxVehicleWheelAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
)
{
    float physxVehicleWheel:dampingRate (
        displayName = "Damping Rate"
        doc = """The damping rate applied to the wheel.
        
              Units: torque * seconds = mass * distance * distance / seconds

              Note: this attribute has to be specified (there is no default).
              """
    )
    float physxVehicleWheel:mass (
        displayName = "Mass"
        doc = """The mass of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleWheel:maxBrakeTorque (
        displayName = "Max Brake Torque"
        doc = """Deprecated. Please use PhysxVehicleBrakesAPI instead.
              
              The maximum brake torque that can be applied to the wheel
              
              Units: mass * distance * distance / seconds / seconds
              
              Note: will be ignored if PhysxVehicleBrakesAPI is used."""
    )
    float physxVehicleWheel:maxHandBrakeTorque (
        displayName = "Max Handbrake Torque"
        doc = """Deprecated. Please use PhysxVehicleBrakesAPI instead.
              
              The maximum hand brake torque that can be applied to the wheel
              
              Units: mass * distance * distance / seconds / seconds
              
              Note: will be ignored if PhysxVehicleBrakesAPI is used."""
    )
    float physxVehicleWheel:maxSteerAngle (
        displayName = "Max Steer Angle"
        doc = """Deprecated. Please use PhysxVehicleSteeringAPI instead.
        
              The maximum steer angle (in radians) that can be achieved by the wheel.
        
              Note: will be ignored if PhysxVehicleSteeringAPI is used."""
    )
    float physxVehicleWheel:moi (
        displayName = "Moment of Inertia"
        doc = """The moment of inertia (metal wheel plus tire) about the rolling axis.
        
              Units: mass * distance * distance

              Note: this attribute has to be specified (there is no default).
              """
    )
    float physxVehicleWheel:radius (
        displayName = "Radius"
        doc = """The radius of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleWheel:toeAngle (
        displayName = "Toe Angle"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The wheel toe angle (in radians).
        
              Note: currently, this attribute is only considered for vehicles using the
                    PhysxVehicleDriveStandard drive type.
              
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleWheel:width (
        displayName = "Width"
        doc = """The width of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
}

class "PhysxVehicleTireAPI" (
    doc = """Properties of a PhysX vehicle tire. If the tire setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI applied.
             If the intent is to share the tire setup, PhysxVehicleTireAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
)
{
    float physxVehicleTire:camberStiffness = -1 (
        displayName = "Camber Stiffness"
        doc = """Tire camber stiffness.
              The value has to be greater or equal 0. Camber force can be approximated as: 
              camberStiffness*camberAngle.

              Units: mass * distance / seconds / seconds / radians
              
              Note: the default value -1 is not a valid value as such but indicates that the 
              deprecated attribute camberStiffnessPerUnitGravity should be used instead."""
    )
    float physxVehicleTire:camberStiffnessPerUnitGravity = 0 (
        displayName = "Camber Stiffness per Unit Gravity"
        doc = """Deprecated. Please use camberStiffness instead.
              
              Tire camber stiffness per unit gravitational acceleration. Camber stiffness of the tire is
              calculated as gravitationalAcceleration*camberStiffnessPerUnitGravity.
              
              Note: will be ignored if camberStiffness is used."""
    )
    rel physxVehicleTire:frictionTable (
        displayName = "Friction Table"
        doc = """A relationship to a PhysxVehicleTireFrictionTable instance.
        
              Note: if not defined, a default friction table will be used."""
    )
    float2[] physxVehicleTire:frictionVsSlipGraph (
        displayName = "Friction vs Slip Graph"
        doc = """Graph of friction vs longitudinal slip with 3 points. The friction value extracted from this
              graph will be multiplied with the friction value of the combination of ground material and tire
              type. The array is expected to have 3 entries/points. For the first point, the first value is 
              always zero and the second value is the friction available at zero longitudinal slip. For the
              second point, the first value is the longitudinal slip with maximum friction and the second
              value is the maximum friction. For the third point, the first value is the end point of the graph
              and the second value is the friction for slips greater than the end point of the graph. Note that
              the friction value of the first point is typically smaller than the friction value of the second
              point and the friction value of the second point is typically larger than the friction value of
              the third point.
              
              Note: if not defined, the following values will be used: [(0.0, 1.0), (0.1, 1.0), (1.0, 1.0)]."""
    )
    float2 physxVehicleTire:lateralStiffnessGraph = (0, 0) (
        displayName = "Lateral Stiffness Graph"
        doc = """Tire lateral stiffness is represented as a graph of tire load that has linear behavior
              near zero load and flattens at large loads. The first value of the parameter describes the
              minimum normalized load (load/restLoad) that gives a flat lateral stiffness response to load.
              This value has to be greater or equal 0. The second value of the parameter defines the lateral
              stiffness when the response is flat (the max lateral stiffness) This value has to be positive.

              Units: 
                    Minimum normalized load: unitless
                    Lateral stiffness: mass * distance / seconds / seconds
              
              Note: the default value (0, 0) is not a valid value as such but indicates that the
              deprecated attributes latStiffX and latStiffY should be used instead."""
    )
    float physxVehicleTire:latStiffX = 2 (
        displayName = "Lateral Stiffness X"
        doc = """Deprecated. Please use lateralStiffnessGraph instead.
              
              Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and 
              flattens at large loads. The parameter describes the minimum normalized load (load/restLoad)
              that gives a flat lateral stiffness response to load.
              
              Note: will be ignored if lateralStiffnessGraph is used."""
    )
    float physxVehicleTire:latStiffY (
        displayName = "Lateral Stiffness Y"
        doc = """Deprecated. Please use lateralStiffnessGraph instead.
              
              Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and 
              flattens at large loads. The parameter describes the maximum possible value of lateralStiffness/restLoad
              that occurs when (load/restLoad) >= latStiffX. If load/restLoad is greater than latStiffX then
              the lateral stiffness is latStiffY*restLoad, else the lateral stiffness is latStiffY*(load/latStiffX).
              
              Note: will be ignored if lateralStiffnessGraph is used.
              
              Note: if not defined, the value 17.095 will be used."""
    )
    float physxVehicleTire:longitudinalStiffness = 0 (
        displayName = "Longitudinal Stiffness"
        doc = """Tire longitudinal stiffness.
              The value has to be positive. The resulting longitudinal force can be approximated as: 
              longitudinalStiffness*longitudinalSlip.

              Units: mass * distance / seconds / seconds
              
              Note: the default value 0 is not a valid value as such but indicates that the deprecated
              attribute longitudinalStiffnessPerUnitGravity should be used instead."""
    )
    float physxVehicleTire:longitudinalStiffnessPerUnitGravity (
        displayName = "Longitudinal Stiffness per Unit Gravity"
        doc = """Deprecated. Please use longitudinalStiffness instead.
              
              Tire longitudinal stiffness per unit gravitational acceleration. Longitudinal stiffness of 
              the tire is calculated as gravitationalAcceleration*longitudinalStiffnessPerUnitGravity.
              
              Note: will be ignored if longitudinalStiffness is used.
              
              Note: if not defined, the value 500 will be used."""
    )
    float physxVehicleTire:restLoad = 0 (
        displayName = "Rest Load"
        doc = """The load that develops on the tire when the vehicle is at rest on a flat plane. 
                 The value has to be greater or equal 0.
                 If set to 0, the rest load will get computed automatically using the approximation of:
                 gravitational acceleration * sprungMass.

                 Units: force = mass * distance / seconds / seconds
                 
                 Note: it is not possible for a vehicle to have some rest load values being user-defined
                 and some being computed automatically. Either all values have to be user-defined or all
                 have to be set to 0 for auto-computation."""
    )
}

class "PhysxVehicleSuspensionAPI" (
    doc = """Properties of a PhysX vehicle wheel suspension. If the suspension setup does not need to be shared 
             among vehicle instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI
             applied. If the intent is to share the suspension setup, PhysxVehicleSuspensionAPI can be 
             applied to a separate prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
)
{
    float physxVehicleSuspension:camberAtMaxCompression (
        displayName = "Camber at Max Compression"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at maximum compression.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleSuspension:camberAtMaxDroop (
        displayName = "Camber at Max Droop"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at maximum droop.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleSuspension:camberAtRest (
        displayName = "Camber at Rest"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at its rest position.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleSuspension:maxCompression (
        displayName = "Max Compression"
        doc = """Deprecated. Please use travelDistance instead.
        
              Maximum compression from rest state allowed by suspension spring.
              The value has to be positive.

              Units: distance
              
              Note: will be ignored if travelDistance is authored."""
    )
    float physxVehicleSuspension:maxDroop (
        displayName = "Max Droop"
        doc = """Deprecated. Please use travelDistance instead.
              
              Maximum elongation from rest state allowed by suspension spring.
              The value has to be positive unless it should get computed automatically in which case any
              negative number can be used to indicate as much. It is highly recommended to chose a value
              close to: sprungMass * gravity / springStrength.

              Units: distance
              
              Note: will be ignored if travelDistance is authored."""
    )
    float physxVehicleSuspension:springDamperRate (
        displayName = "Spring Damper Rate"
        doc = """Spring damper rate of suspension unit.

              Units: force * seconds / distance = mass / seconds
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleSuspension:springStrength (
        displayName = "Spring Strength"
        doc = """Spring strength of suspension unit.

              Units: force / distance = mass / seconds / seconds
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleSuspension:sprungMass = 0 (
        displayName = "Sprung Mass"
        doc = """Mass of vehicle that is supported by suspension spring.
              If set to 0, the sprung mass will get computed automatically.

              Units: mass
              
              Note: it is not possible for a vehicle to have some sprung mass values being user-defined and some 
              being computed automatically. Either all values have to be user-defined or all have to be set to 0 
              for auto-computation."""
    )
    float physxVehicleSuspension:travelDistance (
        displayName = "Travel Distance"
        doc = """Distance the wheel can travel along the suspension when going from max compression to 
              max droop. The value has to be positive.

              Units: distance
              
              Note: either this attribute or the deprecated maxCompression/maxDroop have to
              to be specified (with the former taking precedence). When migrating from the
              deprecated attributes, travelDistance can be set to the sum of maxCompression
              and maxDroop."""
    )
}

class "PhysxVehicleWheelAttachmentAPI" (
    doc = """For every wheel of a vehicle, this class defines the attachment properties. Has to 
            be applied to a prim that is a descendant of a prim with PhysxVehicleAPI applied. If the wheel
            attachment prim (the prim with PhysxVehicleWheelAttachmentAPI applied) is a UsdGeomXformable,
            then the position and orientation of the prim will be set by the vehicle simulation. If the
            wheel attachment prim has PhysicsCollisionAPI applied, then none of its descendants are allowed
            to have PhysicsCollisionAPI applied. If the wheel attachment prim is a UsdGeomXformable but does
            not have PhysicsCollisionAPI applied, then exactly one direct child prim among all descendants
            is allowed to have PhysicsCollisionAPI applied. That prim will be interpreted as the collision
            geometry of the wheel and its position and orientation will be set by the vehicle simulation
            too. Note that the relative transform between the collision geometry prim and the wheel attachment
            prim at the start of the simulation will be maintained (the relative transform with respect to
            the center of mass frame of the vehicle rigid body that is). If there is no desire to have the
            vehicle simulation control the transform of the wheel attachment prim, then a prim type that is
            not a UsdGeomXformable should be chosen."""
)
{
    rel physxVehicleWheelAttachment:collisionGroup (
        displayName = "Collision Group"
        doc = "A relationship to a PhysicsCollisionGroup instance that defines what the wheel/suspension scene queries should treat as a ground surface to collide against. If not specified, no specific filtering will be applied."
    )
    bool physxVehicleWheelAttachment:driven (
        displayName = "Driven"
        doc = """Deprecated. Please use PhysxVehicleMultiWheelDifferentialAPI instead.
        
                 True if the tire is driven by the engine through the transmission. Will be ignored if the vehicle
                 has no drive specified (see PhysxVehicleAPI:drive) or if PhysxVehicleMultiWheelDifferentialAPI
                 is used instead."""
    )
    int physxVehicleWheelAttachment:index = -1 (
        displayName = "Index"
        doc = """The index of the wheel attachment. Some other components will reference the wheel attachments
              based on this index. Either all indices of a vehicle's wheel attachments need to be -1 or they
              need to cover all entries in the group {0, .., (numberOfWheels-1)}. All indices being -1 covers 
              the case where wheels are controlled directly through PhysxVehicleWheelControllerAPI, for example,
              or when deprecated APIs are used still."""
    )
    rel physxVehicleWheelAttachment:suspension (
        displayName = "Suspension"
        doc = """A relationship to a PhysxVehicleSuspensionAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleSuspensionAPI
                    applied (none or both of the two is invalid)."""
    )
    float3 physxVehicleWheelAttachment:suspensionForceAppPointOffset (
        displayName = "Suspension Force Application Point Offset"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The location where the suspension force gets applied. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    quatf physxVehicleWheelAttachment:suspensionFrameOrientation = (1, 0, 0, 0) (
        displayName = "Suspension Frame Orientation"
        doc = """The orientation of the suspension frame. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the orientation is specified. If set to true, the orientation is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer. Camber, steer and toe angles are all applied in the suspension
              frame. The vehicle frame transform of the wheel will be defined by: centerOfMassFrame * 
              suspensionFrame * wheelFrame (if physxVehicle:referenceFrameIsCenterOfMass is true,
              else centerOfMassFrame has to be omitted)."""
    )
    point3f physxVehicleWheelAttachment:suspensionFramePosition (
        displayName = "Suspension Frame Position"
        doc = """The point of the suspension at max compression. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the position is specified. If set to true, the position is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer. Camber, steer and toe angles are all applied in the suspension
              frame. The vehicle frame transform of the wheel will be defined by: centerOfMassFrame * 
              suspensionFrame * wheelFrame (if physxVehicle:referenceFrameIsCenterOfMass is true,
              else centerOfMassFrame has to be omitted).
              
              Note: either this attribute or the deprecated wheelCenterOfMassOffset have to
              to be specified (with the former taking precedence)."""
    )
    vector3f physxVehicleWheelAttachment:suspensionTravelDirection (
        displayName = "Suspension Travel Direction"
        doc = """The direction of the suspension travel (towards the wheel). The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the direction is specified. If set to true, the direction is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: this attribute has to be specified (there is no default)."""
    )
    rel physxVehicleWheelAttachment:tire (
        displayName = "Tire"
        doc = """A relationship to a PhysxVehicleTireAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleTireAPI
                    applied (none or both of the two is invalid)."""
    )
    float3 physxVehicleWheelAttachment:tireForceAppPointOffset (
        displayName = "Tire Force Application Point Offset"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The location where the tire force gets applied. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    rel physxVehicleWheelAttachment:wheel (
        displayName = "Wheel"
        doc = """A relationship to a PhysxVehicleWheelAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleWheelAPI
                    applied (none or both of the two is invalid)."""
    )
    float3 physxVehicleWheelAttachment:wheelCenterOfMassOffset (
        displayName = "Wheel Center of Mass Offset"
        doc = """Deprecated. Please use suspensionFramePosition instead.
              
              The location of the wheel centre when at rest. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if suspensionFramePosition is authored."""
    )
    quatf physxVehicleWheelAttachment:wheelFrameOrientation = (1, 0, 0, 0) (
        displayName = "Wheel Frame Orientation"
        doc = """An orientation adjustment of the wheel relative to the suspension frame.
              The rotation angle around the wheel's lateral axis is applied in this frame."""
    )
    point3f physxVehicleWheelAttachment:wheelFramePosition = (0, 0, 0) (
        displayName = "Wheel Frame Position"
        doc = """A position offset of the wheel center relative to the suspension frame.
              Non-zero values might be used, for example, if the steer axis should not go
              through the wheel center."""
    )
}

class "PhysxVehicleSuspensionComplianceAPI" (
    doc = """Compliance describes how toe and camber angle and force application points are 
          affected by suspension compression. Each compliance term is in the form of a graph
          with up to 3 points. The points in the graph consist of a normalized jounce value
          (with 0 meaning fully elongated and 1 fully compressed suspension) and a corresponding
          compliance value (which can be an angle or point etc. depending on the specific
          compliance term). The sequence of points must respresent monotonically increasing
          values of normalized jounce. The actual compliance value will be computed by linear
          interpolation based on the current normalized jounce. If any graph has zero points
          in it, a value of 0.0 is used for the compliance value. If any graph has 1 point
          in it, the compliance value of that point is used directly. This API schema has to
          be applied to a prim with PhysxVehicleWheelAttachmentAPI applied. If defined, then
          this setup takes precedence over the deprecated attributes suspensionForceAppPointOffset
          and tireForceAppPointOffset of the PhysxVehicleWheelAttachmentAPI API schema, the
          deprecated attributes camberAtRest, camberAtMaxCompression, camberAtMaxDroop of the
          PhysxVehicleSuspensionAPI API schema as well as the deprecated attribute toeAngle
          of the PhysxVehicleWheelAPI API schema."""
)
{
    float4[] physxVehicleSuspensionCompliance:suspensionForceAppPoint (
        displayName = "Suspension Force Application Point"
        doc = """Suspension forces are applied at an offset from the suspension frame (see 
              PhysxVehicleWheelAttachmentAPI). An entry in this array defines this offset for a
              given normalized jounce value (which is the first element in the float4 while
              the other 3 elements are used to store the x, y, z coordinates of the offset).
              See the class documentation for general info about the nature of these compliance
              terms and the data requirements."""
    )
    float4[] physxVehicleSuspensionCompliance:tireForceAppPoint (
        displayName = "Tire Force Application Point"
        doc = """Tire forces are applied at an offset from the suspension frame (see 
              PhysxVehicleWheelAttachmentAPI). An entry in this array defines this offset for a
              given normalized jounce value (which is the first element in the float4 while
              the other 3 elements are used to store the x, y, z coordinates of the offset).
              See the class documentation for general info about the nature of these compliance
              terms and the data requirements."""
    )
    float2[] physxVehicleSuspensionCompliance:wheelCamberAngle (
        displayName = "Wheel Camber Angle"
        doc = """A graph of camber angle against normalized jounce with the camber angle expressed
              in radians in the range [-pi, pi]. See the class documentation for general info
              about the nature of these graphs and the data requirements.
              
              Note: the camber angle is applied in the suspension frame (see PhysxVehicleWheelAttachmentAPI)."""
    )
    float2[] physxVehicleSuspensionCompliance:wheelToeAngle (
        displayName = "Wheel Toe Angle"
        doc = """A graph of toe angle against normalized jounce with the toe angle expressed
              in radians in the range [-pi, pi]. See the class documentation for general info
              about the nature of these graphs and the data requirements.
              
              Note: the toe angle is applied in the suspension frame (see PhysxVehicleWheelAttachmentAPI)."""
    )
}

class "PhysxVehicleEngineAPI" (
    doc = """Properties of a PhysX vehicle engine. If the engine setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the engine setup, PhysxVehicleEngineAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
)
{
    float physxVehicleEngine:dampingRateFullThrottle = -1 (
        displayName = "Damping Rate at Full Throttle"
        doc = """Damping rate of engine when full throttle is applied. The value has to be greater
                 or equal 0.

                 Units: torque * seconds = mass * distance * distance / seconds
                 
                 Note: if the clutch is engaged (any gear except neutral) then the damping rate applied 
                 at run-time is an interpolation between dampingRateZeroThrottleClutchEngaged (see 
                 corresponding attribute) and dampingRateFullThrottle:
                 dampingRateZeroThrottleClutchEngaged + 
                 ((dampingRateFullThrottle-dampingRateZeroThrottleClutchEngaged) * acceleratorPedal).
                 
                 Note: if the clutch is disengaged (in neutral gear) the damping rate applied at run-time
                 is an interpolation between dampingRateZeroThrottleClutchDisengaged (see corresponding 
                 attribute) and dampingRateFullThrottle:
                 dampingRateZeroThrottleClutchDisengaged +
                 ((dampingRateFullThrottle-dampingRateZeroThrottleClutchDisengaged) * acceleratorPedal).
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 0.15
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    float physxVehicleEngine:dampingRateZeroThrottleClutchDisengaged = -1 (
        displayName = "Damping Rate at Zero Throttle with Clutch Disengaged"
        doc = '''Damping rate of engine when no throttle is applied and the clutch is disengaged. See attribute "dampingRateFullThrottle"
                 for information about the effect of the value. The value has to be greater or equal 0.

                 Units: torque * seconds = mass * distance * distance / seconds
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 0.35
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used).'''
    )
    float physxVehicleEngine:dampingRateZeroThrottleClutchEngaged = -1 (
        displayName = "Damping Rate at Zero Throttle with Clutch Engaged"
        doc = '''Damping rate of engine when no throttle is applied and the clutch is engaged. 
                 See attribute "dampingRateFullThrottle" for information about the effect of the value. 
                 The value has to be greater or equal 0.

                 Units: torque * seconds = mass * distance * distance / seconds
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 2.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used).'''
    )
    float physxVehicleEngine:idleRotationSpeed = 0 (
        displayName = "Idle Rotation Speed"
        doc = """Rotation speed of the engine when idling. The value has to be greater or equal 0.
        
                 Units: radians / seconds
                 
                 """
    )
    float physxVehicleEngine:maxRotationSpeed = 600 (
        displayName = "Max Rotation Speed"
        doc = """Maximum rotation speed of the engine. The value has to be greater
                 or equal 0.
                 
                 Units: radians / seconds"""
    )
    float physxVehicleEngine:moi (
        displayName = "Moment of Inertia"
        doc = """The moment of inertia of the engine around the axis of rotation. The value has to be positive.

                 Units: mass * distance * distance
        
                 Note: if not defined, the value 1.0 will be used. This default value is in meter length scale 
                 and kilograms and will get adjusted if other units are used."""
    )
    float physxVehicleEngine:peakTorque = -1 (
        displayName = "Peak Torque"
        doc = """Maximum torque available to apply to the engine when the accelerator pedal is at maximum.
                 The value has to be greater or equal 0.

                 Units: mass * distance * distance / seconds / seconds
                 
                 Note: the torque available is the value of the accelerator pedal (in range [0, 1]) multiplied
                 by the normalized torque as computed from torqueCurve (see corresponding attribute)
                 multiplied by peakTorque.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 500.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    float2[] physxVehicleEngine:torqueCurve (
        displayName = "Torque Curve"
        doc = """Graph of normalized torque (torque / peakTorque) against normalized engine speed (engineRotationSpeed / maxRotationSpeed).
                 
                 Note: the normalized engine speed is the x-axis of the graph, while the normalized torque is the y-axis of the graph.
                 No more than 8 data points are supported.
                 
                 Note: if not defined, the following values will be used: [(0.0, 0.8), (0.33, 1.0), (1.0, 0.8)]."""
    )
}

class "PhysxVehicleGearsAPI" (
    doc = """Properties of PhysX vehicle gears. If the gears setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the gears setup, PhysxVehicleGearsAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleGears:ratios (
        displayName = "Ratios"
        doc = """The gear ratios. First entry is for reverse, then there is support for up to 30 gears
                 (neutral has a fixed value of 0 and is not represented in this array). The value for
                 reverse has to be negative, else a positive value is expected and the ratios have to
                 form a descending sequence.
                 
                 Note: if not defined, the following values will be used: [-4.0, 4.0, 2.0, 1.5, 1.1, 1.0]."""
    )
    float physxVehicleGears:ratioScale (
        displayName = "Ratio Scale"
        doc = """Multiplier for gear ratio values. Final gear ratio is computed as ratios[currentGear] * ratioScale.
                 The value has to be positive.
                 
                 Note: if not defined, the value 4.0 will be used."""
    )
    float physxVehicleGears:switchTime (
        displayName = "Switch Time"
        doc = """Time it takes to switch gear.

                 Units: seconds
        
                 Note: if not defined, the value 0.5 will be used."""
    )
}

class "PhysxVehicleAutoGearBoxAPI" (
    doc = """Properties of the PhysX vehicle automatic gear shift box. If the automatic gear shift box setup
             does not need to be shared among vehicle instances, it can be applied to the prim which has 
             PhysxVehicleDriveStandardAPI applied. If the intent is to share the automatic gear shift box
             setup, PhysxVehicleAutoGearBoxAPI can be applied to a separate prim which can be linked to 
             (see PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleAutoGearBox:downRatios (
        displayName = "Down Ratios"
        doc = """Value of normalized engine speed (engineRotationSpeed / maxRotationSpeed) that is low
                 enough to decrement gear. The first entry is for second gear then up to the highest gear.
                 When (engineRotationSpeed / maxRotationSpeed) < downRatios[currentGear] the autobox will
                 begin a transition to currentGear-1 unless currentGear is first gear or neutral or reverse.
                 
                 Note: if not defined, the following values will be used: [0.5, 0.5, 0.5, 0.5]."""
    )
    float physxVehicleAutoGearBox:latency (
        displayName = "Latency"
        doc = """The latency time of the automatic gear shift box. This is the minimum
                 time that must pass between each gear change that is initiated by the automatic gear shift
                 box.

                 Units: seconds
                 
                 Note: if not defined, the value 2.0 will be used."""
    )
    float[] physxVehicleAutoGearBox:upRatios (
        displayName = "Up Ratios"
        doc = """Value of normalized engine speed (engineRotationSpeed / maxRotationSpeed) that is high
                 enough to increment gear. The first entry is for first gear and then up to the
                 second highest gear. When (engineRotationSpeed / maxRotationSpeed) > upRatios[currentGear]
                 the autobox will begin a transition to currentGear+1 unless currentGear is the highest
                 possible gear or neutral or reverse.
                 
                 Note: if not defined, the following values will be used: [0.65, 0.65, 0.65, 0.65]."""
    )
}

class "PhysxVehicleClutchAPI" (
    doc = """Properties of the PhysX vehicle clutch. If the clutch setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the clutch setup, PhysxVehicleClutchAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
)
{
    float physxVehicleClutch:strength (
        displayName = "Strength"
        doc = """Strength of clutch. The value has to be positive.

              The clutch is the mechanism that couples the engine to the wheels. A stronger clutch more
              strongly couples the engine to the wheels, while a clutch of strength zero completely
              decouples the engine from the wheels. Stronger clutches more quickly bring the wheels and
              engine into equilibrium, while weaker clutches take longer, resulting in periods of clutch
              slip and delays in power transmission from the engine to the wheels. The torque generated
              by the clutch is proportional to the clutch strength and the velocity difference between
              the engine's rotational speed and the rotational speed of the driven wheels after accounting
              for the gear ratio. The torque at the clutch is applied negatively to the engine and
              positively to the driven wheels.

              Units: torque * seconds = mass * distance * distance / seconds

              Note: if not defined, the value 10.0 will be used. This default value is in meter length scale 
              and kilograms and will get adjusted if other units are used."""
    )
}

class "PhysxVehicleDriveBasicAPI" (
    doc = '''Very simple drive model for a PhysX vehicle. A torque will be directly applied to the wheels
             that are marked as driven (see PhysxVehicleMultiWheelDifferentialAPI or deprecated attribute
             "driven" in PhysxVehicleWheelAttachmentAPI).
             
             If the drive setup does not need to be shared among vehicle instances, it can be applied to the
             prim which has PhysxVehicleAPI applied. If the intent is to share the drive setup, PhysxVehicleDriveBasicAPI
             can be applied to a separate prim which can be linked to (see PhysxVehicleAPI).'''
)
{
    float physxVehicleDriveBasic:peakTorque = -1 (
        displayName = "Peak Torque"
        doc = '''Maximum torque to generate when the accelerator pedal is at maximum. 
                 The value has to be greater or equal 0.

                 Units: mass * distance * distance / seconds / seconds
                 
                 Note: PhysxVehicleMultiWheelDifferentialAPI can be used to specify which wheels are connected
                 to the drive as well as how the torque should be distributed among those wheels. If the
                 deprecated attribute "driven" of PhysxVehicleWheelAttachmentAPI is used, then each driven
                 wheel can experience a torque up to the value defined in this attribute.
                 
                 Note: the applied torque is the value of the accelerator pedal (in range [0, 1]) multiplied
                 by peakTorque.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 1000.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used).'''
    )
}

class "PhysxVehicleDriveStandardAPI" (
    doc = '''Standard drive model for a PhysX vehicle. The available drive torque will be split equally
             between all the wheels that are marked as driven (see PhysxVehicleMultiWheelDifferentialAPI
             or deprecated attribute "driven" in PhysxVehicleWheelAttachmentAPI) unless the torque
             distributon is configured explicitly (see PhysxVehicleMultiWheelDifferentialAPI for details).
             
             If the drive setup does not need to be shared among vehicle instances, it can be applied to the
             prim which has PhysxVehicleAPI applied. If the intent is to share the drive setup, PhysxVehicleDriveStandardAPI
             can be applied to a separate prim which can be linked to (see PhysxVehicleAPI).'''
)
{
    rel physxVehicleDriveStandard:autoGearBox (
        displayName = "Auto Gear Box"
        doc = """A relationship to a PhysxVehicleAutoGearBoxAPI prim that describes the automatic gear shift box.
                 This relationship is optional and should be omitted if no automatic gear shift is desired. It is
                 also possible to apply PhysxVehicleAutoGearBoxAPI to the prim directly. In that case the relationship
                 must not be defined."""
    )
    rel physxVehicleDriveStandard:clutch (
        displayName = "Clutch"
        doc = """A relationship to a PhysxVehicleClutchAPI prim that describes the clutch.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleClutchAPI
                    applied (none or both of the two is invalid)."""
    )
    rel physxVehicleDriveStandard:engine (
        displayName = "Engine"
        doc = """A relationship to a PhysxVehicleEngineAPI prim that describes the engine.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleEngineAPI
                    applied (none or both of the two is invalid)."""
    )
    rel physxVehicleDriveStandard:gears (
        displayName = "Gears"
        doc = """A relationship to a PhysxVehicleGearsAPI prim that describes the gears.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleGearsAPI
                    applied (none or both of the two is invalid)."""
    )
}

class "PhysxVehicleMultiWheelDifferentialAPI" (
    doc = """Describes which wheels of a vehicle are driven as well as the distribution of the
          drive torque among those wheels. Has to be applied to a prim with PhysxVehicleAPI applied.
          Can only be used for vehicles that have a drive (see PhysxVehicleDriveBasicAPI or
          PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleMultiWheelDifferential:averageWheelSpeedRatios (
        displayName = "Average Wheel Speed Ratios"
        doc = '''Defines how the speeds of the driven wheels get weighted when computing the average wheel
              speed at the clutch (for computing clutch slip). The provided ratios must be in range [0, 1]
              and under normal circumstances sum up to 1. If the attribute is defined, then the length of 
              the array needs to match the length of the "wheels" array. If the attribute is not defined, 
              the wheel speeds of all driven wheels will get weighted equally.
              
              Note: if a vehicle is using a PhysxVehicleDriveBasicAPI drive, then this attribute should not
                    be used.'''
    )
    float[] physxVehicleMultiWheelDifferential:torqueRatios (
        displayName = "Torque Ratios"
        doc = '''Defines how the drive torque should get distributed among the wheels specified in the "wheels"
              attribute. The provided ratios must be in range [-1, 1] and under normal circumstances the absolute
              values should sum up to 1. If the attribute is defined, then the length of the array needs to match
              the length of the "wheels" array. If the attribute is not defined, the torque will get split equally
              among all driven wheels.'''
    )
    int[] physxVehicleMultiWheelDifferential:wheels (
        displayName = "Wheels"
        doc = '''List of indices, referencing the wheels that are driven (receiving torque from the engine). The
              indices refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI.'''
    )
}

class "PhysxVehicleTankDifferentialAPI" (
    apiSchemas = ["PhysxVehicleMultiWheelDifferentialAPI"]
    doc = """Differential to set up a wheeled tank vehicle. Describes which wheels of a vehicle are part of
          the tank tracks. The wheels in each tank track have a constraint applied to them to enforce the
          rule that they all have the same longitudinal speed at the contact point between the wheel and the
          tank track. Driven wheels that are not part of a tank track receive the torque split specified in
          physxVehicleMultiWheelDifferential:torqueRatios. Has to be applied to a prim with PhysxVehicleAPI
          applied. Can only be used for vehicles that have a standard drive (see PhysxVehicleDriveStandardAPI)."""
)
{
    int[] physxVehicleTankDifferential:numberOfWheelsPerTrack (
        displayName = "Number Of Wheels Per Track"
        doc = "For each track, this array holds the number of wheels assigned to that track."
    )
    int[] physxVehicleTankDifferential:thrustIndexPerTrack (
        displayName = "Thrust Index Per Track"
        doc = '''For each track, this array holds the index of the thrust control (0 or 1, see PhysxVehicleTankControllerAPI)
              that drives the track. The length of the array needs to match the length of the 
              "numberOfWheelsPerTrack" array.'''
    )
    int[] physxVehicleTankDifferential:trackToWheelIndices (
        displayName = "Track To Wheel Indices"
        doc = '''For each track, this array holds the start index of the list describing the wheels that
              are assigned to that track (e.g., the list of wheel indices assigned to the track with index
              2 starts at: wheelIndicesInTrackOrder[trackToWheelIndices[2]]). The length of the array needs
              to match the length of the "numberOfWheelsPerTrack" array.'''
    )
    int[] physxVehicleTankDifferential:wheelIndicesInTrackOrder (
        displayName = "Wheel Indices In Track Order"
        doc = '''The wheels (identified by wheel attachment indices, see attribtue "index" of 
              PhysxVehicleWheelAttachmentAPI) assigned to track 0, followed by the wheels assigned to
              track 1 and so on. The length of the array is expected to be equal (or larger than) the number
              of wheels that are assigned to tracks.'''
    )
}

class "PhysxVehicleBrakesAPI" (
    doc = '''Describes a braking system for a vehicle by specifying which wheels are connected to the
          brake control and by defining the brake torque that gets applied to those wheels. Currently,
          up to two braking systems are supported. Use the instance name TfToken "brakes0" and "brakes1"
          of this multipleApply schema to distinguish between the two braking systems. Note that system
          "brakes0" will be coupled to the brake control brake0 while system "brakes1" will be coupled
          to the brake control brake1 (see PhysxVehicleControllerAPI for the brake controls). An example
          for using two systems is to provide brake and handbrake control (the former applying brake
          torque to all wheels and the latter applying brake torque to the rear wheels only). This API
          schema has to be applied to a prim with PhysxVehicleAPI applied. Can only be used for vehicles
          that have a drive (see PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI).'''
)
{
    float physxVehicleBrakes:__INSTANCE_NAME__:maxBrakeTorque = 0 (
        displayName = "Max Brake Torque"
        doc = '''The maximum brake torque that can be generated by the braking system. Has to be greater or equal
              zero. For braking system "brakes0", the brake torque applied to wheels[i] will be
              defined by maxBrakeTorque * torqueMultipliers[i] * physxVehicleController:brake0
              (see PhysxVehicleControllerAPI).
              
              Units: mass * distance * distance / seconds / seconds'''
    )
    float[] physxVehicleBrakes:__INSTANCE_NAME__:torqueMultipliers (
        displayName = "Torque Multipliers"
        doc = '''Defines how much of the max brake torque can be delivered to the wheels that are
              connected to the braking system. The values are unitless multipliers and have to be
              greater or equal to zero. See maxBrakeTorque for how these multipliers affect the
              brake torque applied to a wheel. If the attribute is defined, then the length of the
              array needs to match the length of the "wheels" array. If the attribute is not defined,
              a multiplier value of 1 will be used for all connected wheels.'''
    )
    int[] physxVehicleBrakes:__INSTANCE_NAME__:wheels (
        displayName = "Wheels"
        doc = '''List of indices, referencing the wheels that receive brake torque. The indices
              refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI. If not specified,
              each wheel will receive a brake torque using a torque multiplier of 1 (see attribute
              torqueMultipliers).'''
    )
}

class "PhysxVehicleSteeringAPI" (
    doc = """Describes a steering system for a vehicle by specifying which wheels are connected to the
          steer control and by defining the maximum steer angle for those wheels (see PhysxVehicleControllerAPI
          for the steer control). This API schema has to be applied to a prim with PhysxVehicleAPI applied.
          Can only be used for vehicles that have a drive (see PhysxVehicleDriveBasicAPI or
          PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleSteering:angleMultipliers (
        displayName = "Angle Multipliers"
        doc = '''Allows to adjust the max steer angle for each wheel that is steered. The values are
              unitless multipliers. See maxSteerAngle for how these multipliers affect the steer
              angle of a wheel. If the attribute is defined, then the length of the array needs
              to match the length of the "wheels" array. If the attribute is not defined,
              a multiplier value of 1 will be used for all steered wheels.'''
    )
    float physxVehicleSteering:maxSteerAngle = 0 (
        displayName = "Max Steer Angle"
        doc = """The maximum steer angle (in radians) that can be achieved by the wheels.
              Has to be in range [-pi, pi] when multiplied by the attribute angleMultipliers.
              The steer angle of wheels[i] will be defined by maxSteerAngle * angleMultipliers[i] * 
              physxVehicleController:steer (see PhysxVehicleControllerAPI)."""
    )
    int[] physxVehicleSteering:wheels (
        displayName = "Wheels"
        doc = '''List of indices, referencing the wheels that are going to be steered. The indices
              refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI. If not specified,
              every wheel will be affected by the steer control using an angle multiplier of 1
              (see attribute angleMultipliers).'''
    )
}

class "PhysxVehicleAckermannSteeringAPI" (
    doc = """Describes a steering system with Ackermann correction for two wheels. This system will
          result in asymmetric steer angles such that the line defined by the non-steered wheel axle
          and the lateral lines of the steered wheels meet at the same point. As a consequence, when
          following the path around a curve, the inner wheel will turn more than the outer one. This
          avoids that some wheels need to slip sideways to stay on the path. The specified wheels
          will be connected to the steer control (see PhysxVehicleControllerAPI). This API schema
          has to be applied to a prim with PhysxVehicleAPI applied. Can only be used for vehicles that
          have a drive (see PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI). This API
          schema can not be combined with PhysxVehicleSteeringAPI, only one or the other is allowed."""
)
{
    float physxVehicleAckermannSteering:maxSteerAngle = 0 (
        displayName = "Max Steer Angle"
        doc = """The maximum steer angle (in radians) that can be achieved by the wheels.
              Has to be in range [-pi, pi]. The steer angle of wheel0 will be defined by 
              maxSteerAngle * ackermann_correction(0) * physxVehicleController:steer (see PhysxVehicleControllerAPI)."""
    )
    float physxVehicleAckermannSteering:strength = 1 (
        displayName = "Strength"
        doc = """The strength of the Ackermann correction with 0 denoting no correction and
              1 denoting perfect correction. The value has to be in range [0, 1]."""
    )
    float physxVehicleAckermannSteering:trackWidth (
        displayName = "Track Width"
        doc = """The width of the axle defined by wheel0 and wheel1.
              The value has to be greater than zero.

              Units: distance
              
              Note: this attribute has to be specified (there is no default)."""
    )
    int physxVehicleAckermannSteering:wheel0 (
        displayName = "Wheel 0"
        doc = '''The index of the wheel that is negative along the lateral axis and should get
              connected to the steering system. The index refers to the attribute "index" of
              PhysxVehicleWheelAttachmentAPI.
              
              Note: this attribute has to be specified (there is no default).'''
    )
    int physxVehicleAckermannSteering:wheel1 (
        displayName = "Wheel 1"
        doc = '''The index of the wheel that is positive along the lateral axis and should get
              connected to the steering system. The index refers to the attribute "index" of
              PhysxVehicleWheelAttachmentAPI.
              
              Note: this attribute has to be specified (there is no default).'''
    )
    float physxVehicleAckermannSteering:wheelBase (
        displayName = "Wheel Base"
        doc = """The longitudinal distance between the axle that is affected by Ackermann
              correction and a reference axle. The value has to be greater
              than zero.

              Units: distance
              
              Note: this attribute has to be specified (there is no default)."""
    )
}

class "PhysxVehicleAPI" (
    doc = '''PhysX vehicle. Has to be applied to a prim with PhysicsRigidBodyAPI applied. Wheels can be added by applying PhysxVehicleWheelAttachmentAPI to a prim that is a descendant of the "vehicle" prim.
    
          Note: if the prim has PhysxRigidBodyAPI applied, it should be configured such that disableGravity is set to true since the vehicle simulation will take gravity into account already.'''
)
{
    rel physxVehicle:drive (
        displayName = "Drive"
        doc = """A relationship to a PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI prim that describes the 
                 drive model. If none is specified, it is up to the user to apply torque to the wheels. It is also
                 possible to apply PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI to the prim directly. In 
                 that case the relationship must not be defined."""
    )
    int physxVehicle:highForwardSpeedSubStepCount (
        displayName = "High Forward Speed Sub-step Count"
        doc = """Number of sub-steps performed in the vehicle dynamics update for vehicles that have
              longitudinal speed greater than subStepThresholdLongitudinalSpeed.
              
              Note: if not defined, the value 1 will be used."""
    )
    float physxVehicle:lateralStickyTireDamping = 20 (
        displayName = "Lateral Sticky Tire Damping"
        doc = """The lateral sticky tire damping (per seconds). See documentation about
              longitudinalStickyTireDamping as it is the same concept.
              
              Note: larger values of damping lead to faster approaches to zero. Since the damping behaves
                    like a stiffness with respect to the velocity, too large a value can lead to instabilities."""
    )
    float physxVehicle:lateralStickyTireThresholdSpeed = -1 (
        displayName = "Lateral Sticky Tire Threshold Speed"
        doc = '''The lateral sticky tire threshold speed. See documentation about
              longitudinalStickyTireThresholdSpeed as it is the same concept. Note that the lateral part
              can only enter the "sticky tire" regime if the longitudinal speed is below longitudinalStickyTireThresholdSpeed.
              
              Units: distance / seconds

              Note: the default value -1 is not a valid value as such but will result in the value 0.2 being
              used (in meter length scale or the equivalent if another unit is used).'''
    )
    float physxVehicle:lateralStickyTireThresholdTime = 1 (
        displayName = "Lateral Sticky Tire Threshold Time"
        doc = """The lateral sticky tire threshold time (in seconds). See documentation about
              longitudinalStickyTireThresholdTime as it is the same concept."""
    )
    bool physxVehicle:limitSuspensionExpansionVelocity = 0 (
        displayName = "Limit Suspension Expansion Velocity"
        doc = """Limit the suspension expansion dynamics.
              
              When a hit with the ground is detected, the suspension jounce will be set such that the wheel
\t          is placed on the ground. This can result in large changes to jounce within a single simulation
              frame, if the ground surface has high frequency or if the simulation time step is large. As a
              result, large damping forces can evolve and cause undesired behavior. If this parameter is set
              to true, the suspension expansion speed will be limited to what can be achieved given the time
              step, suspension stiffness etc. As a consequence, handling of the vehicle will be affected as
              the wheel might loose contact with the ground more easily.
              
              Note: this will apply to the suspensions of all wheels."""
    )
    float physxVehicle:longitudinalStickyTireDamping = 200 (
        displayName = "Longitudinal Sticky Tire Damping"
        doc = '''The longitudinal sticky tire damping (per seconds). Has to be greater or equal 0.
              Describes the rate at which the velocity constraint approaches zero when entering the "sticky tire"
              regime. More details on the "sticky tire" regime can be found in the documentation of the
              longitudinalStickyTireThresholdSpeed attribute.
              
              Note: larger values of damping lead to faster approaches to zero. Since the damping behaves
                    like a stiffness with respect to the velocity, too large a value can lead to instabilities.'''
    )
    float physxVehicle:longitudinalStickyTireThresholdSpeed = -1 (
        displayName = "Longitudinal Sticky Tire Threshold Speed"
        doc = '''The longitudinal sticky tire threshold speed. Has to be greater 
              or equal 0. A tire enters the "sticky tire" regime when its longitudinal speed has been below
              this threshold for a continuous time specified by longitudinalStickyTireThresholdTime. At low
              speeds with no significant brake or drive torque, numerical error begins to dominate and it
              can be difficult to bring the vehicle to rest. A solution to this problem is to recognise that
              the vehicle is close to rest and to replace the tire forces with velocity constraints that will
              bring the vehicle to rest. For the purpose of this documentation, this regime is referred to as
              the "sticky tire" regime.

              Units: distance / seconds
              
              Note: the default value -1 is not a valid value as such but will result in the value 0.2 being
              used (in meter length scale or the equivalent if another unit is used).'''
    )
    float physxVehicle:longitudinalStickyTireThresholdTime = 1 (
        displayName = "Longitudinal Sticky Tire Threshold Time"
        doc = '''The longitudinal sticky tire threshold time (in seconds). Has to be greater or equal 0.
              A tire enters the "sticky tire" regime when it has been below the speed specified by
              longitudinalStickyTireThresholdSpeed for this continuous time. More details on the
              "sticky tire" regime can be found in the documentation of the longitudinalStickyTireThresholdSpeed
              attribute.'''
    )
    int physxVehicle:lowForwardSpeedSubStepCount (
        displayName = "Low Forward Speed Sub-step Count"
        doc = """Number of sub-steps performed in the vehicle dynamics update for vehicles that have
              longitudinal speed lower than subStepThresholdLongitudinalSpeed.
              
              Note: if not defined, the value 3 will be used."""
    )
    float physxVehicle:minActiveLongitudinalSlipDenominator = 0 (
        displayName = "Min Active Longitudinal Slip Denominator"
        doc = """The minimum denominator used in the longitudinal slip calculation when a wheel experiences
              drive or brake torque. For low longitudinal velocities, the
              computation of the longitudinal slip can become unstable. This value defines the minimum velocity
              to use when computing the longitudinal slip. The value has to be positive.
              
              Units: distance / seconds

              Note: the default value 0 is not a valid value as such but will result in the value 0.1 being
              used (in meter length scale or the equivalent if another unit is used).
              
              Note: it is recommended to have minActiveLongitudinalSlipDenominator < minPassiveLongitudinalSlipDenominator."""
    )
    float physxVehicle:minLateralSlipDenominator = 0 (
        displayName = "Min Lateral Slip Denominator"
        doc = """The minimum denominator used in the lateral slip calculation.
              For low longitudinal velocities, the computation of the lateral slip can become unstable.
              This value defines the minimum longitudinal velocity to use when computing the lateral slip.
              The value has to be positive.

              Units: distance / seconds
              
              Note: the default value 0 is not a valid value as such but will result in the value 1.0 being
              used (in meter length scale or the equivalent if another unit is used).
              
              Note: larger simulation timesteps typically require larger values of minLateralSlipDenominator."""
    )
    float physxVehicle:minLongitudinalSlipDenominator (
        displayName = "Min Longitudinal Slip Denominator"
        doc = """Deprecated. Please use minPassiveLongitudinalSlipDenominator instead.
              
              The minimum denominator used in the longitudinal slip calculation.
              For low longitudinal velocities, the computation of the longitudinal slip can become 
              unstable. This value defines the minimum velocity to use when computing the longitudinal slip.

              Units: distance / seconds
              
              Note: will be ignored if minPassiveLongitudinalSlipDenominator is used.
              
              Note: if not defined, the value 4.0 will be used. This default value is in meter length scale 
              and will get adjusted if another unit is used."""
    )
    float physxVehicle:minPassiveLongitudinalSlipDenominator = 0 (
        displayName = "Min Passive Longitudinal Slip Denominator"
        doc = """The minimum denominator used in the longitudinal slip calculation when a wheel experiences no
              drive and no brake torque. For low longitudinal velocities, the
              computation of the longitudinal slip can become unstable. This value defines the minimum velocity
              to use when computing the longitudinal slip. The value has to be positive.
              
              Units: distance / seconds

              Note: the default value 0 is not a valid value as such but indicates that the deprecated
              attribute minLongitudinalSlipDenominator should be used instead.
              
              Note: it is recommended to have minActiveLongitudinalSlipDenominator < minPassiveLongitudinalSlipDenominator."""
    )
    float physxVehicle:subStepThresholdLongitudinalSpeed (
        displayName = "Sub-step Threshold Longitudinal Speed"
        doc = """Threshold speed that is used to categorize vehicle speed as low speed or high speed for
              choosing the sub-step count.

              Units: distance / seconds

              Note: if not defined, the value 5.0 will be used. This default value is in meter length scale 
              and will get adjusted if another unit is used."""
    )
    uniform token physxVehicle:suspensionLineQueryType = "raycast" (
        allowedTokens = ["raycast", "sweep"]
        displayName = "Suspension Line Query Type"
        doc = """Collision of the wheels with the ground surface is detected through scene queries along the suspension direction. 
              This attribute defines whether a raycast or a sweep should be used as the query type. Raycasts are faster while sweeps
              can represent the wheel shape better and thus react earlier to ground surface changes."""
    )
    bool physxVehicle:vehicleEnabled = 1 (
        displayName = "Vehicle Simulation Enabled"
        doc = """Defines whether the vehicle simulation update loop will run for the vehicle or not.
              
              Note: if set to false, the prim's rigid body will still get simulated (the PhysicsRigidBodyAPI API schema
              can be used to turn the body into a kinematic or set velocities to zero at that point).
              
              Note: it is an illegal setup to have a vehicle enabled, while the prim's rigid body is disabled or kinematic."""
    )
}

class "PhysxVehicleControllerAPI" (
    doc = "PhysX vehicle controller that samples user input to drive the vehicle. Has to be applied to a prim with PhysxVehicleAPI applied."
)
{
    float physxVehicleController:accelerator = 0 (
        displayName = "Accelerator"
        doc = "Driven vehicle. Throttle input, 0.0 to 1.0."
    )
    float physxVehicleController:brake = 0 (
        displayName = "Brake"
        doc = """Deprecated. Please use brake0/brake1 instead.
              
              Driven vehicle. Brake input, 0.0 to 1.0."""
    )
    float physxVehicleController:brake0 = 0 (
        displayName = "Brake 0"
        doc = '''Brake control for braking system "brakes0" (see PhysxVehicleBrakesAPI)
                 that triggers the connected brakes and defines the brake strength.
                 Value has to be in range [0.0, 1.0].'''
    )
    float physxVehicleController:brake1 = 0 (
        displayName = "Brake 1"
        doc = '''Brake control for braking system "brakes1" (see PhysxVehicleBrakesAPI)
                 that triggers the connected brakes and defines the brake strength.
                 Value has to be in range [0.0, 1.0].'''
    )
    float physxVehicleController:handbrake = 0 (
        displayName = "Handbrake"
        doc = """Deprecated. Please use brake0/brake1 instead.
              
              Driven vehicle. Handbrake input, 0.0 to 1.0."""
    )
    float physxVehicleController:steer = 0 (
        displayName = "Steer"
        doc = """Steer control for the steering system (see PhysxVehicleSteeringAPI).
                 Defines the extent of the wheels' steer angles with respect to the
                 maximum steer angle. Value has to be in range [-1.0, 1.0]."""
    )
    float physxVehicleController:steerLeft = 0 (
        displayName = "Steer Left"
        doc = """Deprecated. Please use steer instead.
              
              Driven vehicle. Left steering input. 0.0 to 1.0. Net steering is the aggregate of steerRight and steerLeft."""
    )
    float physxVehicleController:steerRight = 0 (
        displayName = "Steer Right"
        doc = """Deprecated. Please use steer instead.
              
              Driven vehicle. Right steering input, 0.0 to 1.0. Net steering is the aggregate of steerRight and steerLeft."""
    )
    int physxVehicleController:targetGear = 255 (
        displayName = "Target Gear"
        doc = """Driven vehicle. Desired gear to shift into. -1 = Reverse, 0 = Neutral, 1 = First etc.
              The special value 255 is used to denote automatic forward gear shifting (similar to 'D' in
              automatic transmissions).
              
              Note: if set to automatic gear shifting, the vehicle is expected to have an autobox
                    defined (see PhysxVehicleAutoGearBoxAPI).
        
              Note: please be aware that the target gear definition differs from the PhysX vehicle API."""
    )
}

class "PhysxVehicleTankControllerAPI" (
    apiSchemas = ["PhysxVehicleControllerAPI"]
    doc = '''PhysX vehicle tank controller to divert torque from the engine to the wheels of the tracks
          of a wheel based tank vehicle (see PhysxVehicleTankDifferentialAPI). Note that the "accelerator"
          attribute of PhysxVehicleControllerAPI still drives the engine torque whereas the thrust controls
          introduced here define how that torque gets diverted to the wheels, so both controls need to
          be used to drive a wheel based tank vehicle usually. This API schema has to be applied to a prim
          with PhysxVehicleAPI applied. Can only be used for vehicles that have a standard drive and a
          tank differential defined (see PhysxVehicleDriveStandardAPI, PhysxVehicleTankDifferentialAPI).'''
)
{
    float physxVehicleTankController:thrust0 = 0 (
        displayName = "Thrust 0"
        doc = """Magnitude of thrust to apply to the tracks that are assigned to thrust control 0.
              Values have to be in [-1.0, 1.0] with the sign dictating whether the thrust will be
              applied positively or negatively with respect to the gearing ratio."""
    )
    float physxVehicleTankController:thrust1 = 0 (
        displayName = "Thrust 1"
        doc = """Magnitude of thrust to apply to the tracks that are assigned to thrust control 1.
              Values have to be in [-1.0, 1.0] with the sign dictating whether the thrust will be
              applied positively or negatively with respect to the gearing ratio."""
    )
}

class "PhysxVehicleWheelControllerAPI" (
    doc = "PhysX wheel controller that samples user input and allows direct control of the wheel torques and steer angle to drive the vehicle. Has to be applied to a prim with PhysxVehicleWheelAttachmentAPI applied and be a descendant of a prim with a PhysxVehicleAPI applied."
)
{
    float physxVehicleWheelController:brakeTorque = 0 (
        displayName = "Brake Torque"
        doc = """Torque to decrease wheel angular rate and slow down.
              The value has to be greater or equal zero.
              
              Units: mass * distance * distance / seconds / seconds
              """
    )
    float physxVehicleWheelController:driveTorque = 0 (
        displayName = "Drive Torque"
        doc = """Torque to increase wheel angular rate and speed up.
        
                Units: mass * distance * distance / seconds / seconds
        """
    )
    float physxVehicleWheelController:steerAngle = 0 (
        displayName = "Steer Angle"
        doc = "Steer angle of the wheel in radians."
    )
}

class "PhysxVehicleNonlinearCommandResponseAPI" (
    doc = '''Describes a system of graphs to define nonlinear responses to PhysxVehicleControllerAPI
          command values like accelerator, brake0, brake1 and steer. The normalized response will be
          a function of the command value and the longitudinal vehicle speed. The response will be
          computed by interpolating between the points of the graph and then interpolating those
          results again between the closest graphs. One example usage of nonlinear command response
          is a brake pedal that has an almost flat response when tipped slightly but a very strong
          response from a certain point on. Another example is the steering wheel showing a strong
          response for a large input at low speed but only a weak response at high speed.

          This multipleApply schema can be used to control the response to steering (use instance name
          TfToken "steer") and braking (use instance name TfTokens "brakes0" or "brakes1"). It can
          also control the response to the accelerator but only in combination with the basic drive (use
          instance name TfToken "drive"). Furthermore, this API has to be applied to the appropriate
          prims to take effect: "steer" has to be applied to a prim that has PhysxVehicleSteeringAPI or
          PhysxVehicleAckermannSteeringAPI applied. "brakes0"/"brakes1" have to be applied to a prim that
          has PhysxVehicleBrakesAPI:brakes0/brakes1 applied. "drive" has to be applied to a prim that
          has PhysxVehicleDriveBasicAPI applied.'''
)
{
    float[] physxVehicleNCR:__INSTANCE_NAME__:commandValues (
        displayName = "Command Values"
        doc = """The command values to define response graphs for. Each listed command value
              (in range [0, 1], steer commands are treated symmetrically) has to point to a graph
              in speedResponses. The command values refer to steer, brake0 etc. The values
              have to be strictly increasing. The number of entries has to match the number of
              entries in speedResponsesPerCommandValue and is limited to 8. Every command value
              needs at least one entry in speedResponses."""
    )
    float2[] physxVehicleNCR:__INSTANCE_NAME__:speedResponses (
        displayName = "Speed Responses"
        doc = """List of pairs that define points in graphs of longitudinal speed vs. normalized
              response. The first value of the pair is the longitudinal speed, the second value
              is the expected response (in range [0, 1]). The longitudinal speed values within
              a graph have to be strictly increasing. The maximum allowed number of entries is 64.
              See speedResponsesPerCommandValue for how the different graphs are accessed."""
    )
    int[] physxVehicleNCR:__INSTANCE_NAME__:speedResponsesPerCommandValue (
        displayName = "Speed Responses Per Command Value"
        doc = """List of indices pointing to the start of a response graph for a certain command
              value. The index values have to be strictly increasing. The graph for command
              value commandValues[i] starts at entry speedResponses[speedResponsesPerCommandValue[i]]
              and stops at entry speedResponses[speedResponsesPerCommandValue[i+1] - 1]. The
              number of entries has to match the number of entries in commandValues and has the
              same maximum limit."""
    )
}

class "PhysxCameraAPI" (
    doc = "PhysX camera."
)
{
    bool alwaysUpdateEnabled = 1 (
        displayName = "Always Update Enabled"
        doc = """When enabled, always update this camera whether it is the active camera or not. This prevents cameras from slewing 
                 into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
    rel physxCamera:subject (
        displayName = "Subject"
        doc = "Reference to the subject this camera is to track."
    )
}

class "PhysxCameraFollowAPI" (
    apiSchemas = ["PhysxCameraAPI"]
    doc = "PhysX camera that follows behind the subject as it moves."
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        displayName = "Camera Position Time Constant"
        doc = "Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"
    )
    float physxFollowCamera:followMaxDistance (
        displayName = "Follow Max Distance"
        doc = "The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"
    )
    float physxFollowCamera:followMaxSpeed (
        displayName = "Follow Max Speed"
        doc = "The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"
    )
    float physxFollowCamera:followMinDistance (
        displayName = "Follow Min Distance"
        doc = "The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"
    )
    float physxFollowCamera:followMinSpeed (
        displayName = "Follow Min Speed"
        doc = "The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"
    )
    float physxFollowCamera:followTurnRateGain (
        displayName = "Follow Turn Rate Gain"
        doc = "A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject. Can be any positive or negative number. e.g. 0.2"
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        displayName = "Look Ahead Max Speed"
        doc = "The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"
    )
    float physxFollowCamera:lookAheadMinDistance (
        displayName = "Look Ahead Min Distance"
        doc = "The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"
    )
    float physxFollowCamera:lookAheadMinSpeed (
        displayName = "Look Ahead Min Speed"
        doc = "The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        displayName = "Look Ahead Turn Rate Gain"
        doc = "A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"
    )
    float physxFollowCamera:lookPositionHeight (
        displayName = "Look Position Height"
        doc = "Distance to elevate the camera look point. e.g. 50.0 cm"
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        displayName = "Look Position Time Constant"
        doc = "Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"
    )
    float physxFollowCamera:pitchAngle (
        displayName = "Pitch Angle"
        doc = "The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        displayName = "Pitch Angle Time Constant"
        doc = "Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"
    )
    float3 physxFollowCamera:positionOffset (
        displayName = "Position Offset"
        doc = "Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        displayName = "Slow Pitch Angle Speed"
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        displayName = "Slow Speed Pitch Angle Scale"
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        displayName = "Velocity Normal Min Speed"
        doc = "The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"
    )
    float physxFollowCamera:yawAngle (
        displayName = "Yaw Angle"
        doc = "The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"
    )
    float physxFollowCamera:yawRateTimeConstant (
        displayName = "Yaw Rate Time Constant"
        doc = "Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        displayName = "Look Ahead Max Distance"
        doc = "The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g.  500.0 cm"
    )
}

class "PhysxCameraFollowLookAPI" (
    apiSchemas = ["PhysxCameraFollowAPI"]
    doc = "PhysX camera that follows behind the subject's forward vector as it moves. Assumes the subject is always upright and does not roll."
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        displayName = "Downhill Ground Angle"
        doc = "The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"
    )
    float physxFollowLookCamera:downHillGroundPitch (
        displayName = "Downhill Ground Pitch"
        doc = "The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:followReverseDistance (
        displayName = "Follow Reverse Distance"
        doc = "The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"
    )
    float physxFollowLookCamera:followReverseSpeed (
        displayName = "Follow Reverse Speed"
        doc = "The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"
    )
    float physxFollowLookCamera:upHillGroundAngle (
        displayName = "Uphill Ground Angle"
        doc = "The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"
    )
    float physxFollowLookCamera:upHillGroundPitch (
        displayName = "Uphill Ground Pitch"
        doc = "The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        displayName = "Velocity Blend Time Constant"
        doc = "Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"
    )
}

class "PhysxCameraFollowVelocityAPI" (
    apiSchemas = ["PhysxCameraFollowAPI"]
    doc = "PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."
)
{
}

class "PhysxCameraDroneAPI" (
    apiSchemas = ["PhysxCameraAPI"]
    doc = "PhysX drone camera that follows its subject from the air as it drives."
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        displayName = "Feed Forward Velocity Gain"
        doc = "The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"
    )
    float physxDroneCamera:followDistance (
        displayName = "Follow Distance"
        doc = "The distance from the subject that the drone attempts to maintain. e.g. 30 meters"
    )
    float physxDroneCamera:followHeight (
        displayName = "Follow Height"
        doc = "The height above the subject that the drone attmepts to maintain. e.g. 15 meters"
    )
    float physxDroneCamera:horizontalVelocityGain (
        displayName = "Horizontal Velocity Gain"
        doc = "The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"
    )
    float physxDroneCamera:maxDistance (
        displayName = "Max Distance"
        doc = "The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"
    )
    float physxDroneCamera:maxSpeed (
        displayName = "Max Speed"
        doc = "The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"
    )
    float3 physxDroneCamera:positionOffset (
        displayName = "Position Offset"
        doc = "An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        displayName = "Rotation Filter Time Constant"
        doc = "The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        displayName = "Velocity Filter Time Constant"
        doc = "The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"
    )
    float physxDroneCamera:verticalVelocityGain (
        displayName = "Vertical Velocity Gain"
        doc = "The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"
    )
}

class PhysxParticleSystem "PhysxParticleSystem" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    PhysX particle system, used to simulate fluids, cloth and inflatables. This prim allows the user to configure the
    solver parameters that are common to the particle objects associated with this system via their particleSystem relationship."""
)
{
    float contactOffset = -inf (
        displayName = "Contact Offset"
        doc = """Contact offset used for collisions with non-particle objects such as rigid or deformable bodies.
            Must be larger than restOffset. Default value -inf results in a simulation-determined value.
            Range: (restOffset, inf)
            Units: distance"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    bool enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Enable continuous collision detection for particles to help avoid tunneling effects."
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    float fluidRestOffset = -inf (
        displayName = "Fluid Rest Offset"
        doc = """Rest offset used for fluid-fluid particle interactions. Must be smaller than particleContactOffset.
            Default value -inf results in a simulation-determined value.
            Range: [0, particleContactOffset)
            Units: distance"""
    )
    bool globalSelfCollisionEnabled = 1 (
        displayGroup = "Advanced"
        displayName = "Global Self Collision Enabled"
        doc = """If True, self collisions follow particle-object-specific settings. If False, all particle self collisions are disabled, regardless of any other settings.
            Improves performance if self collisions are not needed."""
    )
    float maxDepenetrationVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum velocity permitted to be introduced by the solver to depenetrate intersecting particles.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    int maxNeighborhood = 96 (
        displayGroup = "Advanced"
        displayName = "Max Neighborhood"
        doc = "Defines how many particle neighbors per particle may be considered for interaction computations."
    )
    float maxVelocity = inf (
        displayName = "Max Velocity"
        doc = """Maximum particle velocity. See also cflCoefficient in PhysxPBDMaterialAPI for limiting particle-particle relative velocity.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    float neighborhoodScale = 1.01 (
        displayGroup = "Advanced"
        displayName = "Neighborhood Scale"
        doc = """Defines by how much the default neighborhood volume is inflated to ensure that all relevant neighboring particles are found while particles interact. Simulations with high relative velocities might require larger volumes.
            Range: [1, inf)"""
    )
    bool nonParticleCollisionEnabled = 1 (
        displayGroup = "Advanced"
        displayName = "Nonparticle-Objects Collision Enabled"
        doc = """Enable or disable particle collision with nonparticle objects for all particles in the system.
            Improves performance if nonparticle collisions are not needed."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    float particleContactOffset = 0.05 (
        displayName = "Particle Contact Offset"
        doc = """Contact offset used for interactions between particles. Must be larger than solid and fluid rest offsets.
            Range: (max(solidRestOffset, fluidRestOffset), inf)
            Units: distance"""
    )
    bool particleSystemEnabled = 1 (
        displayName = "Particle System Enabled"
        doc = "Enable or disable the particle system."
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    float restOffset = -inf (
        displayName = "Rest Offset"
        doc = """Rest offset used for collisions with non-particle objects such as rigid or deformable bodies.
            Must be smaller than contact offset. Default value -inf results in a simulation-determined value.
            Range: [0, contactOffset)
            Units: distance"""
    )
    rel simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this particle system. By default,
        this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )
    float solidRestOffset = -inf (
        displayName = "Solid Rest Offset"
        doc = """Rest offset used for solid-solid or solid-fluid particle interactions. Must be smaller than particleContactOffset.
            Default value -inf results in a simulation-determined value.
            Range: [0, particleContactOffset)
            Units: distance"""
    )
    int solverPositionIterationCount = 16 (
        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = """Number of solver iterations for position.
            Range: [1, 255]"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float3 wind = (0, 0, 0) (
        displayName = "Wind"
        doc = """The wind applied to the current particle system.
            Range: (-inf, inf)
            Units: distance / seconds"""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "PhysxParticleIsosurfaceAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Defines settings to extract an isosurface from the fluid particles in the particle system.
    The isosurface extraction is a post-processing step that does not affect the particle dynamics."""
)
{
    string physxParticleIsosurface:gridFilteringPasses = "GSRS" (
        displayName = "Grid Filtering Passes"
        doc = 'Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. Up to 32 passes.'
    )
    float physxParticleIsosurface:gridSmoothingRadius = -inf (
        displayName = "Grid Smoothing Radius"
        doc = """The radius used during the smoothing process on the grid. Default value -inf results in a simulation-determined value.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxParticleIsosurface:gridSpacing = -inf (
        displayName = "Grid Spacing"
        doc = """Cell Size of the grid used for isosurface extraction. Default value -inf results in a simulation-determined value.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxParticleIsosurface:isosurfaceEnabled = 1 (
        displayName = "Isosurface Enabled"
        doc = "Enable or disable the creation of an isosurface."
    )
    uniform int physxParticleIsosurface:maxSubgrids = 2048 (
        displayName = "Max Subgrids"
        doc = """Maximum number of blocks the sparse grid structure can contain.
            Range: [1, inf)"""
    )
    uniform int physxParticleIsosurface:maxTriangles = 2097152 (
        displayName = "Max Triangles"
        doc = """Maximum number of triangles the extracted isosurface can have.
            Range: [1, inf)"""
    )
    uniform int physxParticleIsosurface:maxVertices = 1048576 (
        displayName = "Max Vertices"
        doc = """Maximum number of vertices the extracted isosurface can have.
            Range: [3, inf)"""
    )
    int physxParticleIsosurface:numMeshNormalSmoothingPasses = 4 (
        displayName = "Mesh Normal Smoothing Passes"
        doc = """Number of smoothing passes applied to the normals of the generated isosurface triangle mesh.
            Range: [0, inf)"""
    )
    int physxParticleIsosurface:numMeshSmoothingPasses = 4 (
        displayName = "Mesh Smoothing Passes"
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
            Range: [0, inf)"""
    )
    float physxParticleIsosurface:surfaceDistance = -inf (
        displayName = "Surface Distance"
        doc = """Distance from particle center to isosurface. Default value -inf results in a simulation-determined value.
            Range: [0, 2.5*gridSpacing)
            Units: distance"""
    )
}

class "PhysxParticleSmoothingAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Controls smoothing of simulated particle positions in a post-processing step.
    The smoothing post-processing only affects the rendering output including isosurface generation, and not the particle dynamics.
    Affects point based primitives with PhysxParticleSetAPI, which are defined as fluid."""
)
{
    bool physxParticleSmoothing:particleSmoothingEnabled = 1 (
        displayName = "Particle Smoothing Enabled"
        doc = "Enable or disable smoothingStrength of particle positions."
    )
    float physxParticleSmoothing:strength = 0.8 (
        displayName = "Strength"
        doc = """Smoothing coefficient for particle positions.
            Range: [0, 1]
            Units: dimensionless"""
    )
}

class "PhysxParticleAnisotropyAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Defines settings to compute anisotropic scaling of particles in a post-processing step.
    The anisotropy post-processing only affects the rendering output including isosurface generation, and not the particle dynamics.
    Affects point instancer primitives with PhysxParticleSetAPI, which are defined as fluid."""
)
{
    float physxParticleAnisotropy:max = 2 (
        displayName = "Max"
        doc = """Maximum scale of anisotropy relative to fluidRestOffset for rendering.
            Range: [min, inf)
            Units: dimensionless"""
    )
    float physxParticleAnisotropy:min = 0.2 (
        displayName = "Min"
        doc = """Minimum scale of anisotropy relative to fluidRestOffset for rendering.
            Range: [0, max]
            Units: dimensionless"""
    )
    bool physxParticleAnisotropy:particleAnisotropyEnabled = 1 (
        displayName = "Particle Anisotropy Enabled"
        doc = "Enables use of fluid anisotropy information for rendering."
    )
    float physxParticleAnisotropy:scale = 1 (
        displayName = "Scale"
        doc = """Scale of anisotropy for rendering.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysxDiffuseParticlesAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomPoints or UsdGeomPointInstancer primitive with PhysxParticleSetAPI. 
    Defines settings that the particle simulation uses to spawn diffuse particles.
    The diffuse particles are a render-only effect and do not affect the particle dynamics."""
)
{
    float physxDiffuseParticles:airDrag = 0 (
        displayName = "Air Drag"
        doc = """Air drag force factor for spray particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxDiffuseParticles:bubbleDrag = 0.5 (
        displayName = "BubbleDrag"
        doc = """Fluid drag force factor for bubble particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxDiffuseParticles:buoyancy = 0.8 (
        displayName = "Buoyancy"
        doc = """Buoyancy force factor for bubble particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxDiffuseParticles:collisionDecay = 0.5 (
        displayName = "Collision Decay"
        doc = """Decay factor of diffuse particles' lifetime after they collide with shapes. 0 == lifetime remains unchanged, 1 == particle disappears immediately.
            Range: [0, 1]
            Units: dimensionless"""
    )
    bool physxDiffuseParticles:diffuseParticlesEnabled = 1 (
        displayName = "Diffuse Particles Enabled"
        doc = "Enable or disable the creation of diffuse particles."
    )
    float physxDiffuseParticles:divergenceWeight = 5 (
        displayName = "Divergence Weight"
        doc = """Contribution from divergence when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDiffuseParticles:kineticEnergyWeight = 0.01 (
        displayName = "Kinetic Energy Weight"
        doc = """Contribution from kinetic energy when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDiffuseParticles:lifetime = 5 (
        displayName = "Lifetime"
        doc = """Lifetime of a spawned particle before it is removed again.
            Range: [0, inf)
            Units: seconds"""
    )
    uniform float physxDiffuseParticles:maxDiffuseParticleMultiplier = -inf (
        displayName = "Max Diffuse Particle Multiplier"
        doc = """Maximum number of diffuse particles that can be present in the simulation relative to the number
              of non-diffuse particles.
              Range: [0.0, inf)
              Default value -inf means default is picked by the simulation."""
    )
    float physxDiffuseParticles:pressureWeight = 1 (
        displayName = "Pressure Weight"
        doc = """Contribution from pressure when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDiffuseParticles:threshold = 0.01 (
        displayName = "Threshold"
        doc = """Kinetic energy threshold a particle must reach to spawn a diffuse particle.
            Range: [0, inf)
            Units: energy = mass * distance * distance / seconds / seconds"""
    )
    bool physxDiffuseParticles:useAccurateVelocity = 0 (
        displayGroup = "Advanced"
        displayName = "Use Accurate Velocity"
        doc = "Enables accurate particle velocity estimation."
    )
}

class "PhysxPBDMaterialAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a USD Material. PhysX position-based-dynamics (PBD) material for particles used to simulate fluids, cloth and inflatables.
    Currently, only a single material per particle system is supported which applies to all objects that are associated with the system."""
)
{
    float physxPBDMaterial:adhesion = 0 (
        displayGroup = "Advanced"
        displayName = "Adhesion"
        doc = """Adhesion for interactions between particles (solid or fluid), and rigids or deformables.
            Adhesion also applies to solid-solid particle interactions, but is multiplied with the particle adhesion scale.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:adhesionOffsetScale = 0 (
        displayGroup = "Advanced"
        displayName = "Adhesion Offset Scale"
        doc = """Offset scale defining the offset at which adhesion ceases to take effect. For interactions between particles (fluid or solid),
            and rigids or deformables, the adhesion offset is defined relative to the rest offset. For solid particle-particle
            interactions, the adhesion offset is defined relative to the solid rest offset.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:cflCoefficient = 1 (
        displayGroup = "Advanced"
        displayName = "CFL Coefficient"
        doc = """This coefficient scales the CFL term used to limit relative motion between approaching fluid particles. A very large value disables the limit.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:cohesion = 0 (
        displayName = "Cohesion"
        doc = """Cohesion for interaction between fluid particles.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:damping = 0 (
        displayName = "Damping"
        doc = """Global velocity damping coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxPBDMaterial:density = 0 (
        displayName = "Density"
        doc = """Density used to compute particle object mass. If set to 0.0, the simulation determines a default density.
            A density or mass set with a PhysicsMassAPI on a particle object overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    float physxPBDMaterial:drag = 0 (
        displayName = "Drag"
        doc = """Deprecated. PhysxParticleClothAPI is deprecated and will be replaced by a new deformable schema in a future release.
            Drag coefficient for cloth and inflatable particle objects. Basic aerodynamic drag model coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxPBDMaterial:friction = 0.2 (
        displayName = "Friction"
        doc = """Friction coefficient. The maximal friction force tangential to the surface is equal to the normal force times
            the friction. The friction takes effect in all interactions between particles and rigids or deformables.
            For solid particle-particle interactions it is multiplied by the particle friction scale.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:gravityScale = 1 (
        displayGroup = "Advanced"
        displayName = "Gravity Scale"
        doc = """Gravitational acceleration scaling factor, for example (-1.0 would invert gravity).
            Range: (-inf, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:lift = 0 (
        displayName = "Lift"
        doc = """Deprecated. PhysxParticleClothAPI is deprecated and will be replaced by a new deformable schema in a future release.
            Particle cloth Lift coefficient for cloth and inflatable particle objects. Basic aerodynamic lift model coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxPBDMaterial:particleAdhesionScale = 1 (
        displayGroup = "Advanced"
        displayName = "Particle Adhesion Scale"
        doc = """Coefficient that scales adhesion for solid particle-particle interations.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:particleFrictionScale = 1 (
        displayGroup = "Advanced"
        displayName = "Particle Friction Scale"
        doc = """Coefficient that scales friction for solid particle-particle interations.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:surfaceTension = 0 (
        displayName = "Surface Tension"
        doc = """Surface tension for fluid particles.
            Range: [0, inf) 
            Units: 1 / (distance * distance * distance)"""
    )
    float physxPBDMaterial:viscosity = 0 (
        displayName = "Viscosity"
        doc = """Viscosity for fluid particles.
            Range: [0, inf) 
            Units: dimensionless"""
    )
    float physxPBDMaterial:vorticityConfinement = 0 (
        displayGroup = "Advanced"
        displayName = "Vorticity Confinement"
        doc = """Vorticity confinement for fluid particles. Helps prevent energy loss due to numerical solver by adding vortex-like accelerations to the particles.
            Range: [0, inf)
            Units: dimensionless """
    )
}

class "PhysxParticleAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Do not apply. Provides parameters shared among particle objects."""
)
{
    bool physxParticle:particleEnabled = 1 (
        displayName = "Particle Enabled"
        doc = "Enable or disable the particle object."
    )
    int physxParticle:particleGroup = 0 (
        displayGroup = "Advanced"
        displayName = "Particle Group"
        doc = """Group Id of the particles. Particles / objects in different groups in the same system collide with each other.
            Within the same group in the same system, the collision behavior is controlled by the selfCollision parameter.
            Range: [0, 2^20)"""
    )
    rel physxParticle:particleSystem (
        displayName = "Particle System"
        doc = "Single particle system that the particle-based object belongs to."
    )
    bool physxParticle:selfCollision = 1 (
        displayName = "Self Collision"
        doc = "Enables self-collision of the particles or of the particle object."
    )
}

class "PhysxParticleSetAPI" (
    apiSchemas = ["PhysxParticleAPI"]
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomPointInstancer or a UsdGeomPointBased. Creates a set of particles for granular (i.e. solid-particle) material or fluid simulation with PhysX."""
)
{
    bool physxParticle:fluid = 1 (
        displayName = "Fluid"
        doc = "Flag to toggle simulation as fluid (True) or solid (False)."
    )
    point3f[] physxParticle:simulationPoints (
        displayGroup = "Advanced"
        displayName = "Simulation Points"
        doc = """This attribute is read-only and is updated from simulation to capture particle-simulation state while smoothed position data
            is written to the render position/points attribute of the UsdGeomPointInstancer/UsdGeomPoints."""
    )
}

class "PhysxParticleSamplingAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh which is Poisson-sampled to generate particles in the particles relationship."""
)
{
    int physxParticleSampling:maxSamples = 50000 (
        displayName = "Maximum Number of Samples"
        doc = """Approximate upper bound on the number of samples. Zero means unbounded.
            Range: [0, inf)"""
    )
    rel physxParticleSampling:particles (
        displayName = "Particles"
        doc = "Relationship to the particle set sampled from the mesh."
    )
    float physxParticleSampling:samplingDistance = 0 (
        displayName = "Particle Distance"
        doc = """The distance between the sampled positions. In general, choose a value larger than the corresponding particle rest offset.
            Default value zero means that a suitable value is auto-determined.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxParticleSampling:volume = 1 (
        displayName = "Sample Inside Volume"
        doc = "Whether to sample points inside the mesh or not."
    )
}

class "PhysxParticleClothAPI" (
    apiSchemas = ["PhysxParticleAPI"]
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
    WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh. The mesh is simulated as a particle-based cloth or inflatable, depending on the mesh geometry
    and the pressure attribute. See PhysxAutoParticleClothAPI for an auto-compute helper for cloth springs and dampings."""
)
{
    float physxParticle:pressure = 0 (
        displayName = "Pressure"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Pressure: If > 0, a particle cloth has an additional pressure constraint 
            that provides inflatable (i.e. balloon-like) dynamics. The pressure times the rest volume defines 
            the volume the inflatable tries to match. Pressure only works well for closed or approximately closed meshes.
            Range: [0, inf)
            Units: dimensionless"""
    )
    point3f[] physxParticle:restPoints (
        displayGroup = "Advanced"
        displayName = "Rest Points"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Particle positions in cloth rest configuration."""
    )
    bool physxParticle:selfCollisionFilter = 1 (
        displayGroup = "Advanced"
        displayName = "Self Collision Filter"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Whether the simulation should filter particle-particle collisions based on their rest position distances."""
    )
    float[] physxParticle:springDampings (
        displayGroup = "Advanced"
        displayName = "Spring Dampings"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Coefficients for linear-distance dampers between a pair of particles as defined by index pairs in springIndices.
            Range: [0, inf)
            Units: force * second / distance = mass / second"""
    )
    uniform int2[] physxParticle:springIndices (
        displayGroup = "Advanced"
        displayName = "Spring Indices"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              List of index pairs describing which points are connected by spring constraints."""
    )
    float[] physxParticle:springRestLengths (
        displayGroup = "Advanced"
        displayName = "Spring Rest Lengths"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Spring rest lengths corresponding to spring index pairs.
            Range: (-inf, inf)
            Units: distance"""
    )
    float[] physxParticle:springStiffnesses (
        displayGroup = "Advanced"
        displayName = "Spring Stiffnesses"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Stiffness values for linear-distance springs between a pair of particles as defined by index pairs in springIndices.
            Range: [0, inf)
            Units: force / distance = mass / second / second"""
    )
}

class "PhysxAutoParticleClothAPI" (
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
    WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh with PhysxParticleClothAPI. Defines parameters to automatically compute spring constraints."""
)
{
    bool physxAutoParticleCloth:disableMeshWelding = 0 (
        displayName = "Disable Mesh Welding"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Disable welding of the UsdGeomMesh vertices for cloth simulation."""
    )
    float physxAutoParticleCloth:springBendStiffness = 1.5 (
        displayName = "Bend Stiffness"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Bend stiffness. Represents a stiffness for linear springs placed in a way to counteract bending.
            Range: [0, inf)
            Units:  force / distance = mass / second / second"""
    )
    float physxAutoParticleCloth:springDamping = 10 (
        displayName = "Spring Damping"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Damping on cloth spring constraints. Applies to all constraints parametrized by stiffness attributes.
            Range: [0, inf)
            Units: force * second / distance = mass / second"""
    )
    float physxAutoParticleCloth:springShearStiffness = 1.5 (
        displayName = "Shear Stiffness"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Shear stiffness. Represents a stiffness for linear springs placed in a way to counteract shear.
            Range: [0, inf)
            Units:  force / distance = mass / second / second"""
    )
    float physxAutoParticleCloth:springStretchStiffness = 1.5 (
        displayName = "Stretch Stiffness"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Stretch stiffness. Represents a stiffness for linear springs placed between particles to counteract stretching.
            Range: [0, inf)
            Units: force / distance = mass / second / second"""
    )
}

class "PhysxDeformableBodyMaterialAPI" (
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
    Applied to USD Material. Defines material properties for deformable bodies."""
)
{
    float physxDeformableBodyMaterial:dampingScale = 1 (
        displayName = "Damping Scale"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Experimental parameter. Try a high damping together with a scale of zero for a water-bed like effect.
            Range: [0, 1]
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:density = 0 (
        displayName = "Density"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Material density. If set to 0.0, the simulation determines a default density. A density or mass set with a PhysicsMassAPI overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    float physxDeformableBodyMaterial:dynamicFriction = 0.25 (
        displayName = "Dynamic Friction"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Dynamic friction coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:elasticityDamping = 0.005 (
        displayName = "Elasticity Damping"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Material damping parameter. Use values much smaller than one for good results.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:poissonsRatio = 0.45 (
        displayName = "Poisson's Ratio"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Poissons's ratio which defines the material's volume preservation under stress.
            Range: [0, 0.5]
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:youngsModulus = 50000000 (
        displayName = "Young's Modulus"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            Young's modulus, i.e. the tensile stiffness of the material.
            Range: [0, inf)
            Units: force / area = mass / distance / seconds / seconds"""
    )
}

class "PhysxDeformableSurfaceMaterialAPI" (
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
    WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to USD Material. Defines material properties for deformable surfaces."""
)
{
    float physxDeformableSurfaceMaterial:density = 0 (
        displayName = "Density"
        doc = """Material density. If set to 0.0, the simulation determines a default value. 
            The mass of deformable surface is computed by density * area * thickness.
            A density or mass set with a PhysicsMassAPI overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    float physxDeformableSurfaceMaterial:dynamicFriction = 0.25 (
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDeformableSurfaceMaterial:poissonsRatio = 0 (
        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume preservation under stress. 
            Used to determine in-plane and bending stiffness.
            Range: [0, 0.5]
            Units: dimensionless"""
    )
    float physxDeformableSurfaceMaterial:thickness = 0 (
        displayName = "Thickness"
        doc = """Virtual thickness of cloth mesh. Used to determine in-plane and bending stiffness, and mass from density.
            If set to 0.0, the simulation determines a default value.
            Range: [0.0, inf)
            Units: distance"""
    )
    float physxDeformableSurfaceMaterial:youngsModulus = -inf (
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material. 
            Used to determine in-plane and bending stiffness.
            If set to a negative value, the simulation determines a default value.
            Range: [0, inf)
            Units: force / area = mass / distance / seconds / seconds"""
    )
}

class "PhysxDeformableAPI" (
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
          Do not apply. Base API that provides attributes common to both deformable bodies and surfaces.
          Derived APIs are applied to UsdGeomMesh in order to create a deformable physics object.
          Note that the UsdGeomMesh points attribute becomes a read-only attribute for a deformable as the mesh is driven by the simulation.
          """
)
{
    bool physxDeformable:deformableEnabled = 1 (
        displayName = "Deformable Enabled"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enable or disable the deformable object."""
    )
    bool physxDeformable:enableCCD = 0 (
        displayName = "Enable CCD"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Distance based CCD."""
    )
    float physxDeformable:maxDepenetrationVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
            The maximum velocity permitted to be introduced by the solver to depenetrate intersections.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    point3f[] physxDeformable:restPoints (
        displayGroup = "Advanced"
        displayName = "Rest Points"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Rest points of the UsdGeomMesh in local coordinates.
              Units: distance"""
    )
    bool physxDeformable:selfCollision = 0 (
        displayName = "Enable Self Collision"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enables self collisions on the deformable, preventing self intersections."""
    )
    float physxDeformable:selfCollisionFilterDistance = -inf (
        displayName = "Self Collision Filter Distance"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Distance under which self-collisions are disabled. Default value -inf means default is picked by the simulation.
              Range: [2*physxCollision:restOffset, max_float]
              Units: distance"""
    )
    float physxDeformable:settlingThreshold = 0.1 (
        displayName = "Settling Threshold"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Threshold vertex velocity under which sleep damping is applied in addition to velocity damping.
              Range: [0, inf]
              Units: distance / seconds"""
    )
    uniform int[] physxDeformable:simulationIndices (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Indices"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Simulation mesh indices."""
    )
    rel physxDeformable:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Single PhysicsScene that simulates this deformable. By default,
              this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )
    point3f[] physxDeformable:simulationVelocities (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Vertex Velocities"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Simulation mesh vertex velocities in local coordinates.
              Units: distance / seconds"""
    )
    float physxDeformable:sleepDamping = 10 (
        displayName = "Sleep Damping"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Additional damping term if vertex velocity drops below settlingThreshold.
              Range: [0, inf)
              Units: 1 / seconds"""
    )
    float physxDeformable:sleepThreshold = 0.05 (
        displayName = "Sleep Threshold"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Velocity threshold under which the vertex becomes a candidate for sleeping.
              Range: [0, inf)
              Units: distance / seconds"""
    )
    uint physxDeformable:solverPositionIterationCount = 16 (
        displayName = "Solver Position Iterations"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Number of solver position iterations per time step.
              Range: [1, 255]"""
    )
    float physxDeformable:vertexVelocityDamping = 0.005 (
        displayName = "Vertex Velocity Damping"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Artificial damping on the vertex velocity, which may approximate aerodynamic drag.
              Range: [0, inf)
              Units: 1 / seconds"""
    )
}

class "PhysxDeformableBodyAPI" (
    apiSchemas = ["PhysxDeformableAPI"]
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
          Applied to a UsdGeomMesh that is to be driven by a deformable body simulation.
          See PhysxDeformableAPI for information on how to define the deformable body's material properties."""
)
{
    uniform int[] physxDeformable:collisionIndices (
        displayGroup = "Advanced"
        displayName = "Collision Mesh Indices"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Mesh indices that define the collision tetrahedral mesh together with the collisionPoints attribute."""
    )
    point3f[] physxDeformable:collisionPoints (
        displayGroup = "Advanced"
        displayName = "Collision Mesh Points"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Mesh points in local coordinates that define the collision tetrahedral mesh together with the collisionIndices attribute.
              This attribute is read-only and may be updated from simulation data to reflect the current simulation state."""
    )
    point3f[] physxDeformable:collisionRestPoints (
        displayGroup = "Advanced"
        displayName = "Collision Mesh Rest Points"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Mesh rest points in local coordinates that define the rest pose of the collision tetrahedral mesh together with the collisionIndices attribute."""
    )
    bool physxDeformable:disableGravity = 0 (
        displayName = "Disable Gravity"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Disable gravity for the actor."""
    )
    point3f[] physxDeformable:simulationPoints (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Points"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Simulation mesh points in local coordinates that define the simulation tetrahedral mesh together with the simulationIndices attribute.
              This attribute may be updated from simulation data to reflect the current simulation state."""
    )
    point3f[] physxDeformable:simulationRestPoints (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Rest Points"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Mesh rest points in local coordinates that define the rest pose of the simulation tetrahedral mesh together with the simulationIndices attribute."""
    )
}

class "PhysxDeformableSurfaceAPI" (
    apiSchemas = ["PhysxDeformableAPI"]
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
          WARNING: This is a draft API; the design is not fixed and may change in the future.
          Applied to a UsdGeomMesh that is to be simulated as a deformable surface.
          See PhysxDeformableAPI for information on how to define the deformable surface's material properties."""
)
{
    float physxDeformableSurface:bendingStiffnessScale = 0 (
        displayName = "Bending Stiffness Scale"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Scales bending stiffness computed from Young's modulus, Poisson's ratio, and the cloth thickness.
              Range: [0, inf)
              Units: dimensionless"""
    )
    uint physxDeformableSurface:collisionIterationMultiplier = 1 (
        displayGroup = "Advanced"
        displayName = "Collision Iteration Multiplier"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Determines how many collision subiterations are used in each solver iteration.
              By default, collision constraints are applied once per solver iteration.
              Increasing this value applies collision constraints more frequently within each solver iteration.
              For example, a value of 2 means collision constraints are applied twice per solver iteration 
              (i.e., collision constraints are applied 2 x solverPositionIterationCount times per time step).
              Increasing this value does not update collision pairs more frequently; refer to collisionPairUpdateFrequency for that.
              Range [1, solverPositionIterationCount/2]"""
    )
    uint physxDeformableSurface:collisionPairUpdateFrequency = 1 (
        displayGroup = "Advanced"
        displayName = "Collision Pair Update Frequency"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Determines how often cloth-to-cloth collision pairs are updated during each time step. 
              Increasing this value results in more frequent updates to the contact pairs, which provides better contact points. 
              For example, a value of 2 means collision pairs are updated twice per time step: 
              once at the beginning and once in the middle of the time step (i.e., during the middle solver iteration). 
              If set to 0, the solver adaptively determines when to update the cloth-to-cloth contact pairs, instead of using a fixed frequency.
              Range [1, solverPositionIterationCount]"""
    )
    bool physxDeformableSurface:flatteningEnabled = 0 (
        displayName = "Flattening Enabled"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              If enabled, bending forces are applied such that the surface flattens, i.e., neighboring triangles become coplanar.
              If disabled, the forces drive toward the bend at the rest state."""
    )
    float physxDeformableSurface:maxVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Velocity"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Maximum velocity: the velocity of each cloth vertex is clamped by this maximum velocity value.
              If set to a negative value, the simulation determines a default value.
              Range: [0, inf)
              Units: distance / seconds"""
    )
}

class PhysxPhysicsAttachment "PhysxPhysicsAttachment" (
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
          Represents attachments between physics actors, for example, between a rigid body and a deformable body, or a deformable body and a particle cloth."""
)
{
    rel actor0 (
        displayName = "Actor 0"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Reference to the first actor."""
    )
    rel actor1 (
        displayName = "Actor 1"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Reference to the second actor."""
    )
    bool attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enable or disable the attachment."""
    )
    uint[] collisionFilterIndices0 (
        displayGroup = "Advanced"
        displayName = "Collision Filter Indices Actor 0"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Indices to geometry of Actor 0 that should not generate collisions with Actor 1 as specified by filterType0. Ignored for rigid bodies."""
    )
    uint[] collisionFilterIndices1 (
        displayGroup = "Advanced"
        displayName = "Collision Filter Indices Actor 1"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Indices to mesh triangle/tet/hex/etc. of Actor 1 that should not generate collisions with Actor 0. Ignored for rigid bodies."""
    )
    uniform token filterType0 (
        allowedTokens = ["Vertices", "Geometry"]
        displayGroup = "Advanced"
        displayName = "Filter Type 0"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Specify if indices in collisionFilterIndices0 correspond to vertices; or mesh cell-geometry, i.e. triangles, tetrahedrons, etc."""
    )
    uniform token filterType1 (
        allowedTokens = ["Vertices", "Geometry"]
        displayGroup = "Advanced"
        displayName = "Filter Type 1"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Specify if indices in collisionFilterIndices1 correspond to vertices; or mesh cell-geometry, i.e. triangles, tetrahedrons, etc."""
    )
    point3f[] points0 (
        displayGroup = "Advanced"
        displayName = "Points Actor 0"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Attachment points in Actor 0 local space, defined in the actor's rest state, if it is deformable. Elements correspond one-to-one to elements in points1 attribute."""
    )
    point3f[] points1 (
        displayGroup = "Advanced"
        displayName = "Points Actor 1"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Attachment points in Actor 1 local space, defined in the actor's rest state, if it is deformable. Elements correspond one-to-one to elements in points0 attribute."""
    )
}

class "PhysxAutoAttachmentAPI" (
    doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
          Auto generates the attachment points and filtering ids based on the attributes defined in the API."""
)
{
    float physxAutoAttachment:collisionFilteringOffset = -inf (
        displayName = "Collision Filtering Offset"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Filtering ids are generated for deformable mesh vertices if their distance to the other actor's volume is smaller than the offset. Use heuristic by default.
              Range: [0, inf)
              Units: distance"""
    )
    float physxAutoAttachment:deformableVertexOverlapOffset = 0 (
        displayName = "Deformable Vertex Overlap Offset"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Deformable mesh vertices are attached if their distance to the other actor's volume is smaller than the offset.
              Range: [0, inf)
              Units: distance"""
    )
    bool physxAutoAttachment:enableCollisionFiltering = 1 (
        displayName = "Enable Collision Filtering"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enables adding collision filtering in the vicinity of the attachment points."""
    )
    bool physxAutoAttachment:enableDeformableFilteringPairs = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Deformable Collision Filtering Pairs"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enables geometry pair based collision filtering for deformable-deformable attachments. 
              By default a filtered geometry of one actor is filtered against all geometries of the other actor."""
    )
    bool physxAutoAttachment:enableDeformableVertexAttachments = 1 (
        displayName = "Enable Deformable Vertex Attachments"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enables attaching deformable mesh vertices which overlap with the other actor's volume."""
    )
    bool physxAutoAttachment:enableRigidSurfaceAttachments = 0 (
        displayName = "Enable Rigid Surface Attachments"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Enables sampling attachment points on the rigid actor's surface."""
    )
    float physxAutoAttachment:rigidSurfaceSamplingDistance = -inf (
        displayName = "Rigid Surface Sampling Distance"
        doc = """Deprecated: Will be replaced by a new deformable schema in a future release.
              Attachment points on the rigid surface are positioned such that their typical neighbor distance matches the sampling distance. Use heuristic by default.
              Range: [0, inf)
              Units: distance"""
    )
}

